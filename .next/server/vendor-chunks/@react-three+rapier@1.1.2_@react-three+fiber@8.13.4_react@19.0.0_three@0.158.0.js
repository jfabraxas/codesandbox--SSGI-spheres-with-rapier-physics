"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three+rapier@1.1.2_@react-three+fiber@8.13.4_react@19.0.0_three@0.158.0";
exports.ids = ["vendor-chunks/@react-three+rapier@1.1.2_@react-three+fiber@8.13.4_react@19.0.0_three@0.158.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-three+rapier@1.1.2_@react-three+fiber@8.13.4_react@19.0.0_three@0.158.0/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-three+rapier@1.1.2_@react-three+fiber@8.13.4_react@19.0.0_three@0.158.0/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyCollider: () => (/* binding */ AnyCollider),\n/* harmony export */   BallCollider: () => (/* binding */ BallCollider),\n/* harmony export */   CapsuleCollider: () => (/* binding */ CapsuleCollider),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   ConeCollider: () => (/* binding */ ConeCollider),\n/* harmony export */   ConvexHullCollider: () => (/* binding */ ConvexHullCollider),\n/* harmony export */   CuboidCollider: () => (/* binding */ CuboidCollider),\n/* harmony export */   CylinderCollider: () => (/* binding */ CylinderCollider),\n/* harmony export */   HeightfieldCollider: () => (/* binding */ HeightfieldCollider),\n/* harmony export */   InstancedRigidBodies: () => (/* binding */ InstancedRigidBodies),\n/* harmony export */   MeshCollider: () => (/* binding */ MeshCollider),\n/* harmony export */   Physics: () => (/* binding */ Physics),\n/* harmony export */   RapierCollider: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   RapierRigidBody: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RoundConeCollider: () => (/* binding */ RoundConeCollider),\n/* harmony export */   RoundCuboidCollider: () => (/* binding */ RoundCuboidCollider),\n/* harmony export */   RoundCylinderCollider: () => (/* binding */ RoundCylinderCollider),\n/* harmony export */   TrimeshCollider: () => (/* binding */ TrimeshCollider),\n/* harmony export */   euler: () => (/* binding */ euler),\n/* harmony export */   interactionGroups: () => (/* binding */ interactionGroups),\n/* harmony export */   quat: () => (/* binding */ quat),\n/* harmony export */   useAfterPhysicsStep: () => (/* binding */ useAfterPhysicsStep),\n/* harmony export */   useBeforePhysicsStep: () => (/* binding */ useBeforePhysicsStep),\n/* harmony export */   useFixedJoint: () => (/* binding */ useFixedJoint),\n/* harmony export */   useImpulseJoint: () => (/* binding */ useImpulseJoint),\n/* harmony export */   usePrismaticJoint: () => (/* binding */ usePrismaticJoint),\n/* harmony export */   useRapier: () => (/* binding */ useRapier),\n/* harmony export */   useRevoluteJoint: () => (/* binding */ useRevoluteJoint),\n/* harmony export */   useSphericalJoint: () => (/* binding */ useSphericalJoint),\n/* harmony export */   vec3: () => (/* binding */ vec3)\n/* harmony export */ });\n/* harmony import */ var _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/.pnpm/@dimforge+rapier3d-compat@0.11.2/node_modules/@dimforge/rapier3d-compat/rapier.es.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/.pnpm/@react-three+fiber@8.13.4_@types+react@19.1.9_react-dom@19.0.0_react@19.0.0_three@0.158.0/node_modules/@react-three/fiber/dist/index-27578f8f.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.4.6_react-dom@19.0.0_react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/.pnpm/three@0.158.0/node_modules/three/build/three.module.js\");\n/* harmony import */ var use_asset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! use-asset */ \"(ssr)/./node_modules/.pnpm/use-asset@1.0.4_react@19.0.0/node_modules/use-asset/dist/index.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/.pnpm/three-stdlib@2.23.9_three@0.158.0/node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst _quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Euler();\nconst _vector3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst _matrix4 = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nconst _rotation = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nconst _scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\nconst tupleToObject = (tuple, keys) => {\n  return keys.reduce((obj, key, i) => {\n    obj[key] = tuple[i];\n    return obj;\n  }, {});\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Vector3 || v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(callback);\n  const raf = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  const lastFrame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    cb.current = callback;\n  }, [callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\n\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\n\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\n\nvar FrameStepper$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld);\n\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n\n    _matrix4.decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n\n      childColliderProps.push(colliderProps);\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : (0,three_stdlib__WEBPACK_IMPORTED_MODULE_4__.mergeVertices)(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS | _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n\n  return rest;\n};\n\nconst useMutableCallback = fn => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n}; // External hooks\n\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\n\n\nconst useRapier = () => {\n  const rapier = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(rapierContext);\n  if (!rapier) throw new Error('react-three-rapier: useRapier must be used within <Physics />!');\n  return rapier;\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\n\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\n\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n}; // Internal hooks\n\n/**\n * @internal\n */\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"group\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.get(instance, prop);\n    },\n\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.set(instance, prop, value);\n    }\n\n  };\n  const proxy = new Proxy({}, handler);\n\n  const reset = () => {\n    instance = undefined;\n  };\n  /**\n   * Return the proxy and a reset function\n   */\n\n\n  return {\n    proxy,\n    reset\n  };\n};\n\nconst rapierContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\n\nconst importRapier = async () => {\n  let r = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/.pnpm/@dimforge+rapier3d-compat@0.11.2/node_modules/@dimforge/rapier3d-compat/rapier.es.js\"));\n  await r.init();\n  return r;\n};\n\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    maxStabilizationIterations = 1,\n    maxVelocityFrictionIterations = 8,\n    maxVelocityIterations = 4,\n    predictionDistance = 0.002,\n    erp = 0.8\n  } = props;\n  const rapier = (0,use_asset__WEBPACK_IMPORTED_MODULE_5__.useAsset)(importRapier);\n  const {\n    invalidate\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.z)();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []); // Update mutable props\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    worldProxy.gravity = vectorArrayToVector3(gravity);\n    worldProxy.integrationParameters.maxStabilizationIterations = maxStabilizationIterations;\n    worldProxy.integrationParameters.maxVelocityFrictionIterations = maxVelocityFrictionIterations;\n    worldProxy.integrationParameters.maxVelocityIterations = maxVelocityIterations;\n    worldProxy.integrationParameters.predictionDistance = predictionDistance;\n    worldProxy.integrationParameters.erp = erp;\n  }, [worldProxy, ...gravity, maxStabilizationIterations, maxVelocityIterations, maxVelocityFrictionIterations, predictionDistance, erp]);\n  const getSourceFromColliderHandle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(handle => {\n    var _collider$parent;\n\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(dt => {\n    const world = worldProxy;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(dt, 0, 0.5);\n\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      } // New states\n\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    rapier,\n    world: worldProxy,\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\n\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  const getInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n\n    return ref.current;\n  }, dependencyList);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n\n    const destroy = () => destroyFn(instance);\n\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\n\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\n\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\n\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Euler(x, y, z);\n};\n\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(defaultValue); // Update the forwarded ref when the inner ref changes\n\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n\n    return forwardedRef;\n  }\n\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // We spread the props out here to make sure that the ref is updated when the props change.\n\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useRigidBodyContext = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RigidBodyContext);\n\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion,\n    transformState\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray); // Only provide a object state after the ref has been set\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const instanceWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n\n  const {\n    // instanced props\n    children,\n    instances,\n    colliderNodes = [],\n    // wrapper object props\n    position,\n    rotation,\n    quaternion,\n    scale\n  } = props,\n        rigidBodyProps = _objectWithoutProperties(props, _excluded);\n\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n\n    return undefined;\n  };\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []); // Update the RigidBodyStates whenever the instances change\n\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n\n    return state;\n  };\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, colliderNodes.map((node, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), tupleToObject(body1LocalFrame, [\"x\", \"y\", \"z\", \"w\"]), vectorArrayToVector3(body2Anchor), tupleToObject(body2LocalFrame, [\"x\", \"y\", \"z\", \"w\"])));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXRocmVlK3JhcGllckAxLjEuMl9AcmVhY3QtdGhyZWUrZmliZXJAOC4xMy40X3JlYWN0QDE5LjAuMF90aHJlZUAwLjE1OC4wL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcmFwaWVyL2Rpc3QvcmVhY3QtdGhyZWUtcmFwaWVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRztBQUMyQjtBQUNyRTtBQUNnRjtBQUNwQjtBQUMvRTtBQUNROztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDZDQUFVO0FBQ2xDLElBQUksd0NBQUs7QUFDVCxxQkFBcUIsMENBQU87QUFDNUIsSUFBSSwyQ0FBUTtBQUNaLHFCQUFxQiwwQ0FBTztBQUM1QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDZDQUFVO0FBQ2hDLG1CQUFtQiwwQ0FBTzs7QUFFMUI7QUFDQTtBQUNBLGFBQWEsMENBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNkNBQVU7QUFDN0I7QUFDQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRTJjIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy8ucG5wbS9AcmVhY3QtdGhyZWUrcmFwaWVyQDEuMS4yX0ByZWFjdC10aHJlZStmaWJlckA4LjEzLjRfcmVhY3RAMTkuMC4wX3RocmVlQDAuMTU4LjAvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9yYXBpZXIvZGlzdC9yZWFjdC10aHJlZS1yYXBpZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdGl2ZUV2ZW50cywgQ29sbGlkZXJEZXNjLCBFdmVudFF1ZXVlLCBSaWdpZEJvZHlEZXNjIH0gZnJvbSAnQGRpbWZvcmdlL3JhcGllcjNkLWNvbXBhdCc7XG5leHBvcnQgeyBDb2VmZmljaWVudENvbWJpbmVSdWxlLCBDb2xsaWRlciBhcyBSYXBpZXJDb2xsaWRlciwgUmlnaWRCb2R5IGFzIFJhcGllclJpZ2lkQm9keSB9IGZyb20gJ0BkaW1mb3JnZS9yYXBpZXIzZC1jb21wYXQnO1xuaW1wb3J0IHsgdXNlRnJhbWUsIHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgbWVtbywgdXNlTWVtbywgdXNlQ29udGV4dCwgdXNlU3RhdGUsIGNyZWF0ZUNvbnRleHQsIHVzZUNhbGxiYWNrLCBmb3J3YXJkUmVmLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFF1YXRlcm5pb24sIEV1bGVyLCBWZWN0b3IzLCBPYmplY3QzRCwgTWF0cml4NCwgQnVmZmVyQXR0cmlidXRlLCBNYXRoVXRpbHMsIER5bmFtaWNEcmF3VXNhZ2UgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VBc3NldCB9IGZyb20gJ3VzZS1hc3NldCc7XG5pbXBvcnQgeyBtZXJnZVZlcnRpY2VzIH0gZnJvbSAndGhyZWUtc3RkbGliJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgX3F1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xubmV3IEV1bGVyKCk7XG5jb25zdCBfdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5uZXcgT2JqZWN0M0QoKTtcbmNvbnN0IF9tYXRyaXg0ID0gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX3NjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgdmVjdG9yQXJyYXlUb1ZlY3RvcjMgPSBhcnIgPT4ge1xuICBjb25zdCBbeCwgeSwgel0gPSBhcnI7XG4gIHJldHVybiBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcbn07XG5jb25zdCB0dXBsZVRvT2JqZWN0ID0gKHR1cGxlLCBrZXlzKSA9PiB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgob2JqLCBrZXksIGkpID0+IHtcbiAgICBvYmpba2V5XSA9IHR1cGxlW2ldO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG5jb25zdCByYXBpZXJRdWF0ZXJuaW9uVG9RdWF0ZXJuaW9uID0gKHtcbiAgeCxcbiAgeSxcbiAgeixcbiAgd1xufSkgPT4gX3F1YXRlcm5pb24uc2V0KHgsIHksIHosIHcpO1xuY29uc3QgcmlnaWRCb2R5VHlwZU1hcCA9IHtcbiAgZml4ZWQ6IDEsXG4gIGR5bmFtaWM6IDAsXG4gIGtpbmVtYXRpY1Bvc2l0aW9uOiAyLFxuICBraW5lbWF0aWNWZWxvY2l0eTogM1xufTtcbmNvbnN0IHJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nID0gdHlwZSA9PiByaWdpZEJvZHlUeXBlTWFwW3R5cGVdO1xuY29uc3Qgc2NhbGVWZXJ0aWNlcyA9ICh2ZXJ0aWNlcywgc2NhbGUpID0+IHtcbiAgY29uc3Qgc2NhbGVkVmVydHMgPSBBcnJheS5mcm9tKHZlcnRpY2VzKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xuICAgIHNjYWxlZFZlcnRzW2kgKiAzXSAqPSBzY2FsZS54O1xuICAgIHNjYWxlZFZlcnRzW2kgKiAzICsgMV0gKj0gc2NhbGUueTtcbiAgICBzY2FsZWRWZXJ0c1tpICogMyArIDJdICo9IHNjYWxlLno7XG4gIH1cblxuICByZXR1cm4gc2NhbGVkVmVydHM7XG59O1xuY29uc3QgdmVjdG9yVG9UdXBsZSA9IHYgPT4ge1xuICBpZiAoIXYpIHJldHVybiBbMF07XG5cbiAgaWYgKHYgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uKSB7XG4gICAgcmV0dXJuIFt2LngsIHYueSwgdi56LCB2LnddO1xuICB9XG5cbiAgaWYgKHYgaW5zdGFuY2VvZiBWZWN0b3IzIHx8IHYgaW5zdGFuY2VvZiBFdWxlcikge1xuICAgIHJldHVybiBbdi54LCB2LnksIHYuel07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgcmV0dXJuIFt2XTtcbn07XG5mdW5jdGlvbiB1c2VDb25zdChpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG5cbiAgaWYgKHJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICByZWYuY3VycmVudCA9IHtcbiAgICAgIHZhbHVlOiB0eXBlb2YgaW5pdGlhbFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBpbml0aWFsVmFsdWUoKSA6IGluaXRpYWxWYWx1ZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVmLmN1cnJlbnQudmFsdWU7XG59XG5cbmNvbnN0IHVzZVJhZiA9IGNhbGxiYWNrID0+IHtcbiAgY29uc3QgY2IgPSB1c2VSZWYoY2FsbGJhY2spO1xuICBjb25zdCByYWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGxhc3RGcmFtZSA9IHVzZVJlZigwKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0sIFtjYWxsYmFja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gbm93IC0gbGFzdEZyYW1lLmN1cnJlbnQ7XG4gICAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgIGNiLmN1cnJlbnQoZGVsdGEgLyAxMDAwKTtcbiAgICAgIGxhc3RGcmFtZS5jdXJyZW50ID0gbm93O1xuICAgIH07XG5cbiAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICB9LCBbXSk7XG59O1xuXG5jb25zdCBVc2VGcmFtZVN0ZXBwZXIgPSAoe1xuICBvblN0ZXAsXG4gIHVwZGF0ZVByaW9yaXR5XG59KSA9PiB7XG4gIHVzZUZyYW1lKChfLCBkdCkgPT4ge1xuICAgIG9uU3RlcChkdCk7XG4gIH0sIHVwZGF0ZVByaW9yaXR5KTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBSYWZTdGVwcGVyID0gKHtcbiAgb25TdGVwXG59KSA9PiB7XG4gIHVzZVJhZihkdCA9PiB7XG4gICAgb25TdGVwKGR0KTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgRnJhbWVTdGVwcGVyID0gKHtcbiAgb25TdGVwLFxuICB0eXBlLFxuICB1cGRhdGVQcmlvcml0eVxufSkgPT4ge1xuICByZXR1cm4gdHlwZSA9PT0gXCJpbmRlcGVuZGVudFwiID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmFmU3RlcHBlciwge1xuICAgIG9uU3RlcDogb25TdGVwXG4gIH0pIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVXNlRnJhbWVTdGVwcGVyLCB7XG4gICAgb25TdGVwOiBvblN0ZXAsXG4gICAgdXBkYXRlUHJpb3JpdHk6IHVwZGF0ZVByaW9yaXR5XG4gIH0pO1xufTtcblxudmFyIEZyYW1lU3RlcHBlciQxID0gLyojX19QVVJFX18qL21lbW8oRnJhbWVTdGVwcGVyKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQyID0gW1wibWFzc1wiLCBcImxpbmVhckRhbXBpbmdcIiwgXCJhbmd1bGFyRGFtcGluZ1wiLCBcInR5cGVcIiwgXCJvbkNvbGxpc2lvbkVudGVyXCIsIFwib25Db2xsaXNpb25FeGl0XCIsIFwib25JbnRlcnNlY3Rpb25FbnRlclwiLCBcIm9uSW50ZXJzZWN0aW9uRXhpdFwiLCBcIm9uQ29udGFjdEZvcmNlXCIsIFwiY2hpbGRyZW5cIiwgXCJjYW5TbGVlcFwiLCBcImNjZFwiLCBcImdyYXZpdHlTY2FsZVwiXTtcbmNvbnN0IHNjYWxlQ29sbGlkZXJBcmdzID0gKHNoYXBlLCBhcmdzLCBzY2FsZSkgPT4ge1xuICBjb25zdCBuZXdBcmdzID0gYXJncy5zbGljZSgpOyAvLyBIZWlnaHRmaWVsZCB1c2VzIGEgdmVjdG9yXG5cbiAgaWYgKHNoYXBlID09PSBcImhlaWdodGZpZWxkXCIpIHtcbiAgICBjb25zdCBzID0gbmV3QXJnc1szXTtcbiAgICBzLnggKj0gc2NhbGUueDtcbiAgICBzLnggKj0gc2NhbGUueTtcbiAgICBzLnggKj0gc2NhbGUuejtcbiAgICByZXR1cm4gbmV3QXJncztcbiAgfSAvLyBUcmltZXNoIGFuZCBjb252ZXggc2NhbGUgdGhlIHZlcnRpY2VzXG5cblxuICBpZiAoc2hhcGUgPT09IFwidHJpbWVzaFwiIHx8IHNoYXBlID09PSBcImNvbnZleEh1bGxcIikge1xuICAgIG5ld0FyZ3NbMF0gPSBzY2FsZVZlcnRpY2VzKG5ld0FyZ3NbMF0sIHNjYWxlKTtcbiAgICByZXR1cm4gbmV3QXJncztcbiAgfSAvLyBQcmVwZmlsbCB3aXRoIHNvbWUgZXh0cmFcblxuXG4gIGNvbnN0IHNjYWxlQXJyYXkgPSBbc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueiwgc2NhbGUueCwgc2NhbGUueF07XG4gIHJldHVybiBuZXdBcmdzLm1hcCgoYXJnLCBpbmRleCkgPT4gc2NhbGVBcnJheVtpbmRleF0gKiBhcmcpO1xufTtcbmNvbnN0IGNyZWF0ZUNvbGxpZGVyRnJvbU9wdGlvbnMgPSAob3B0aW9ucywgd29ybGQsIHNjYWxlLCBnZXRSaWdpZEJvZHkpID0+IHtcbiAgY29uc3Qgc2NhbGVkQXJncyA9IHNjYWxlQ29sbGlkZXJBcmdzKG9wdGlvbnMuc2hhcGUsIG9wdGlvbnMuYXJncywgc2NhbGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgY29uc3QgZGVzYyA9IENvbGxpZGVyRGVzY1tvcHRpb25zLnNoYXBlXSguLi5zY2FsZWRBcmdzKTtcbiAgcmV0dXJuIHdvcmxkLmNyZWF0ZUNvbGxpZGVyKGRlc2MsIGdldFJpZ2lkQm9keSA9PT0gbnVsbCB8fCBnZXRSaWdpZEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldFJpZ2lkQm9keSgpKTtcbn07XG5jb25zdCBpbW11dGFibGVDb2xsaWRlck9wdGlvbnMgPSBbXCJzaGFwZVwiLCBcImFyZ3NcIl07XG5jb25zdCBtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IgPSBcIlBsZWFzZSBwaWNrIE9OTFkgT05FIG9mIHRoZSBgZGVuc2l0eWAsIGBtYXNzYCBhbmQgYG1hc3NQcm9wZXJ0aWVzYCBvcHRpb25zLlwiO1xuXG5jb25zdCBzZXRDb2xsaWRlck1hc3NPcHRpb25zID0gKGNvbGxpZGVyLCBvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLmRlbnNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IpO1xuICAgIH1cblxuICAgIGNvbGxpZGVyLnNldERlbnNpdHkob3B0aW9ucy5kZW5zaXR5KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5tYXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWFzc1Byb3BlcnRpZXNDb25mbGljdEVycm9yKTtcbiAgICB9XG5cbiAgICBjb2xsaWRlci5zZXRNYXNzKG9wdGlvbnMubWFzcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWFzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbGxpZGVyLnNldE1hc3NQcm9wZXJ0aWVzKG9wdGlvbnMubWFzc1Byb3BlcnRpZXMubWFzcywgb3B0aW9ucy5tYXNzUHJvcGVydGllcy5jZW50ZXJPZk1hc3MsIG9wdGlvbnMubWFzc1Byb3BlcnRpZXMucHJpbmNpcGFsQW5ndWxhckluZXJ0aWEsIG9wdGlvbnMubWFzc1Byb3BlcnRpZXMuYW5ndWxhckluZXJ0aWFMb2NhbEZyYW1lKTtcbiAgfVxufTtcblxuY29uc3QgbXV0YWJsZUNvbGxpZGVyT3B0aW9ucyA9IHtcbiAgc2Vuc29yOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0U2Vuc29yKHZhbHVlKTtcbiAgfSxcbiAgY29sbGlzaW9uR3JvdXBzOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXBzKHZhbHVlKTtcbiAgfSxcbiAgc29sdmVyR3JvdXBzOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0U29sdmVyR3JvdXBzKHZhbHVlKTtcbiAgfSxcbiAgZnJpY3Rpb246IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRGcmljdGlvbih2YWx1ZSk7XG4gIH0sXG4gIGZyaWN0aW9uQ29tYmluZVJ1bGU6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRGcmljdGlvbkNvbWJpbmVSdWxlKHZhbHVlKTtcbiAgfSxcbiAgcmVzdGl0dXRpb246IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRSZXN0aXR1dGlvbih2YWx1ZSk7XG4gIH0sXG4gIHJlc3RpdHV0aW9uQ29tYmluZVJ1bGU6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHZhbHVlKTtcbiAgfSxcbiAgLy8gVG8gbWFrZSBzdXJlIHRoZSBvcHRpb25zIGFsbCBtdXRhYmxlIG9wdGlvbnMgYXJlIGxpc3RlZFxuICBxdWF0ZXJuaW9uOiAoKSA9PiB7fSxcbiAgcG9zaXRpb246ICgpID0+IHt9LFxuICByb3RhdGlvbjogKCkgPT4ge30sXG4gIHNjYWxlOiAoKSA9PiB7fVxufTtcbmNvbnN0IG11dGFibGVDb2xsaWRlck9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhtdXRhYmxlQ29sbGlkZXJPcHRpb25zKTtcbmNvbnN0IHNldENvbGxpZGVyT3B0aW9ucyA9IChjb2xsaWRlciwgb3B0aW9ucywgc3RhdGVzKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjb2xsaWRlci5oYW5kbGUpO1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBfc3RhdGUkd29ybGRQYXJlbnQ7XG5cbiAgICAvLyBVcGRhdGUgY29sbGlkZXIgcG9zaXRpb24gYmFzZWQgb24gdGhlIG9iamVjdCdzIHBvc2l0aW9uXG4gICAgY29uc3QgcGFyZW50V29ybGRTY2FsZSA9IHN0YXRlLm9iamVjdC5wYXJlbnQuZ2V0V29ybGRTY2FsZShfdmVjdG9yMyk7XG4gICAgY29uc3QgcGFyZW50SW52ZXJ0ZWRXb3JsZE1hdHJpeCA9IChfc3RhdGUkd29ybGRQYXJlbnQgPSBzdGF0ZS53b3JsZFBhcmVudCkgPT09IG51bGwgfHwgX3N0YXRlJHdvcmxkUGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkd29ybGRQYXJlbnQubWF0cml4V29ybGQuY2xvbmUoKS5pbnZlcnQoKTtcbiAgICBzdGF0ZS5vYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG4gICAgX21hdHJpeDQuY29weShzdGF0ZS5vYmplY3QubWF0cml4V29ybGQpO1xuXG4gICAgaWYgKHBhcmVudEludmVydGVkV29ybGRNYXRyaXgpIHtcbiAgICAgIF9tYXRyaXg0LnByZW11bHRpcGx5KHBhcmVudEludmVydGVkV29ybGRNYXRyaXgpO1xuICAgIH1cblxuICAgIF9tYXRyaXg0LmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcblxuICAgIGlmIChjb2xsaWRlci5wYXJlbnQoKSkge1xuICAgICAgY29sbGlkZXIuc2V0VHJhbnNsYXRpb25XcnRQYXJlbnQoe1xuICAgICAgICB4OiBfcG9zaXRpb24ueCAqIHBhcmVudFdvcmxkU2NhbGUueCxcbiAgICAgICAgeTogX3Bvc2l0aW9uLnkgKiBwYXJlbnRXb3JsZFNjYWxlLnksXG4gICAgICAgIHo6IF9wb3NpdGlvbi56ICogcGFyZW50V29ybGRTY2FsZS56XG4gICAgICB9KTtcbiAgICAgIGNvbGxpZGVyLnNldFJvdGF0aW9uV3J0UGFyZW50KF9yb3RhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbGxpZGVyLnNldFRyYW5zbGF0aW9uKHtcbiAgICAgICAgeDogX3Bvc2l0aW9uLnggKiBwYXJlbnRXb3JsZFNjYWxlLngsXG4gICAgICAgIHk6IF9wb3NpdGlvbi55ICogcGFyZW50V29ybGRTY2FsZS55LFxuICAgICAgICB6OiBfcG9zaXRpb24ueiAqIHBhcmVudFdvcmxkU2NhbGUuelxuICAgICAgfSk7XG4gICAgICBjb2xsaWRlci5zZXRSb3RhdGlvbihfcm90YXRpb24pO1xuICAgIH1cblxuICAgIG11dGFibGVDb2xsaWRlck9wdGlvbktleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgbXV0YWJsZUNvbGxpZGVyT3B0aW9uc1trZXldKGNvbGxpZGVyLCAvLyBAdHMtaWdub3JlIE9wdGlvbiBkb2VzIG5vdCB3YW50IHRvIGZpdCBpbnRvIHRoZSBmdW5jdGlvbiwgYnV0IGl0IHdpbGxcbiAgICAgICAgb3B0aW9uLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gaGFuZGxlIG1hc3Mgc2VwYXJhdGVseSwgYmVjYXVzZSB0aGUgYXNzaWdubWVudHNcbiAgICAvLyBhcmUgZXhjbHVzaXZlLlxuXG4gICAgc2V0Q29sbGlkZXJNYXNzT3B0aW9ucyhjb2xsaWRlciwgb3B0aW9ucyk7XG4gIH1cbn07XG5jb25zdCB1c2VVcGRhdGVDb2xsaWRlck9wdGlvbnMgPSAoZ2V0Q29sbGlkZXIsIHByb3BzLCBzdGF0ZXMpID0+IHtcbiAgLy8gVE9ETzogSW1wcm92ZSB0aGlzLCBzcGxpdCBlYWNoIHByb3AgaW50byBpdHMgb3duIGVmZmVjdFxuICBjb25zdCBtdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSA9IHVzZU1lbW8oKCkgPT4gbXV0YWJsZUNvbGxpZGVyT3B0aW9uS2V5cy5mbGF0TWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIHZlY3RvclRvVHVwbGUocHJvcHNba2V5XSk7XG4gIH0pLCBbcHJvcHNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldENvbGxpZGVyKCk7XG4gICAgc2V0Q29sbGlkZXJPcHRpb25zKGNvbGxpZGVyLCBwcm9wcywgc3RhdGVzKTtcbiAgfSwgWy4uLm11dGFibGVQcm9wc0FzRmxhdEFycmF5LCBnZXRDb2xsaWRlcl0pO1xufTtcblxuY29uc3QgaXNDaGlsZE9mTWVzaENvbGxpZGVyID0gY2hpbGQgPT4ge1xuICBsZXQgZmxhZyA9IGZhbHNlO1xuICBjaGlsZC50cmF2ZXJzZUFuY2VzdG9ycyhhID0+IHtcbiAgICBpZiAoYS51c2VyRGF0YS5yM1JhcGllclR5cGUgPT09IFwiTWVzaENvbGxpZGVyXCIpIGZsYWcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGZsYWc7XG59O1xuXG5jb25zdCBjcmVhdGVDb2xsaWRlclN0YXRlID0gKGNvbGxpZGVyLCBvYmplY3QsIHJpZ2lkQm9keU9iamVjdCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbGxpZGVyLFxuICAgIHdvcmxkUGFyZW50OiByaWdpZEJvZHlPYmplY3QgfHwgdW5kZWZpbmVkLFxuICAgIG9iamVjdFxuICB9O1xufTtcbmNvbnN0IGF1dG9Db2xsaWRlck1hcCA9IHtcbiAgY3Vib2lkOiBcImN1Ym9pZFwiLFxuICBiYWxsOiBcImJhbGxcIixcbiAgaHVsbDogXCJjb252ZXhIdWxsXCIsXG4gIHRyaW1lc2g6IFwidHJpbWVzaFwiXG59O1xuY29uc3QgY3JlYXRlQ29sbGlkZXJQcm9wc0Zyb21DaGlsZHJlbiA9ICh7XG4gIG9iamVjdCxcbiAgaWdub3JlTWVzaENvbGxpZGVyczogX2lnbm9yZU1lc2hDb2xsaWRlcnMgPSB0cnVlLFxuICBvcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IFtdO1xuICBvYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICBjb25zdCBpbnZlcnRlZFBhcmVudE1hdHJpeFdvcmxkID0gb2JqZWN0Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG5cbiAgY29uc3QgY29sbGlkZXJGcm9tQ2hpbGQgPSBjaGlsZCA9PiB7XG4gICAgaWYgKFwiaXNNZXNoXCIgaW4gY2hpbGQpIHtcbiAgICAgIGlmIChfaWdub3JlTWVzaENvbGxpZGVycyAmJiBpc0NoaWxkT2ZNZXNoQ29sbGlkZXIoY2hpbGQpKSByZXR1cm47XG4gICAgICBjb25zdCB3b3JsZFNjYWxlID0gY2hpbGQuZ2V0V29ybGRTY2FsZShfc2NhbGUpO1xuICAgICAgY29uc3Qgc2hhcGUgPSBhdXRvQ29sbGlkZXJNYXBbb3B0aW9ucy5jb2xsaWRlcnMgfHwgXCJjdWJvaWRcIl07XG4gICAgICBjaGlsZC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cbiAgICAgIF9tYXRyaXg0LmNvcHkoY2hpbGQubWF0cml4V29ybGQpLnByZW11bHRpcGx5KGludmVydGVkUGFyZW50TWF0cml4V29ybGQpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcblxuICAgICAgY29uc3Qgcm90YXRpb25FdWxlciA9IG5ldyBFdWxlcigpLnNldEZyb21RdWF0ZXJuaW9uKF9yb3RhdGlvbiwgXCJYWVpcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdlb21ldHJ5XG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGdldENvbGxpZGVyQXJnc0Zyb21HZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucy5jb2xsaWRlcnMgfHwgXCJjdWJvaWRcIik7XG5cbiAgICAgIGNvbnN0IGNvbGxpZGVyUHJvcHMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY2xlYW5SaWdpZEJvZHlQcm9wc0ZvckNvbGxpZGVyKG9wdGlvbnMpKSwge30sIHtcbiAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICByb3RhdGlvbjogW3JvdGF0aW9uRXVsZXIueCwgcm90YXRpb25FdWxlci55LCByb3RhdGlvbkV1bGVyLnpdLFxuICAgICAgICBwb3NpdGlvbjogW19wb3NpdGlvbi54ICsgb2Zmc2V0LnggKiB3b3JsZFNjYWxlLngsIF9wb3NpdGlvbi55ICsgb2Zmc2V0LnkgKiB3b3JsZFNjYWxlLnksIF9wb3NpdGlvbi56ICsgb2Zmc2V0LnogKiB3b3JsZFNjYWxlLnpdLFxuICAgICAgICBzY2FsZTogW3dvcmxkU2NhbGUueCwgd29ybGRTY2FsZS55LCB3b3JsZFNjYWxlLnpdXG4gICAgICB9KTtcblxuICAgICAgY2hpbGRDb2xsaWRlclByb3BzLnB1c2goY29sbGlkZXJQcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVJbnZpc2libGUpIHtcbiAgICBvYmplY3QudHJhdmVyc2UoY29sbGlkZXJGcm9tQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdC50cmF2ZXJzZVZpc2libGUoY29sbGlkZXJGcm9tQ2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkQ29sbGlkZXJQcm9wcztcbn07XG5jb25zdCBnZXRDb2xsaWRlckFyZ3NGcm9tR2VvbWV0cnkgPSAoZ2VvbWV0cnksIGNvbGxpZGVycykgPT4ge1xuICBzd2l0Y2ggKGNvbGxpZGVycykge1xuICAgIGNhc2UgXCJjdWJvaWRcIjpcbiAgICAgIHtcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib3VuZGluZ0JveFxuICAgICAgICB9ID0gZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBib3VuZGluZ0JveC5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtzaXplLnggLyAyLCBzaXplLnkgLyAyLCBzaXplLnogLyAyXSxcbiAgICAgICAgICBvZmZzZXQ6IGJvdW5kaW5nQm94LmdldENlbnRlcihuZXcgVmVjdG9yMygpKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBcImJhbGxcIjpcbiAgICAgIHtcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib3VuZGluZ1NwaGVyZVxuICAgICAgICB9ID0gZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGJvdW5kaW5nU3BoZXJlLnJhZGl1cztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbcmFkaXVzXSxcbiAgICAgICAgICBvZmZzZXQ6IGJvdW5kaW5nU3BoZXJlLmNlbnRlclxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBcInRyaW1lc2hcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jbG9uZWRHZW9tZXRyeSRpbmRleDtcblxuICAgICAgICBjb25zdCBjbG9uZWRHZW9tZXRyeSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuY2xvbmUoKSA6IG1lcmdlVmVydGljZXMoZ2VvbWV0cnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtjbG9uZWRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5LCAoX2Nsb25lZEdlb21ldHJ5JGluZGV4ID0gY2xvbmVkR2VvbWV0cnkuaW5kZXgpID09PSBudWxsIHx8IF9jbG9uZWRHZW9tZXRyeSRpbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Nsb25lZEdlb21ldHJ5JGluZGV4LmFycmF5XSxcbiAgICAgICAgICBvZmZzZXQ6IG5ldyBWZWN0b3IzKClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJodWxsXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGcgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtnLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXldLFxuICAgICAgICAgIG9mZnNldDogbmV3IFZlY3RvcjMoKVxuICAgICAgICB9O1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhcmdzOiBbXSxcbiAgICBvZmZzZXQ6IG5ldyBWZWN0b3IzKClcbiAgfTtcbn07XG5jb25zdCBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMgPSBwcm9wcyA9PiB7XG4gIHJldHVybiB7XG4gICAgY29sbGlzaW9uOiAhIShwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uQ29sbGlzaW9uRW50ZXIgfHwgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkNvbGxpc2lvbkV4aXQgfHwgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkludGVyc2VjdGlvbkVudGVyIHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25JbnRlcnNlY3Rpb25FeGl0KSxcbiAgICBjb250YWN0Rm9yY2U6ICEhKHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25Db250YWN0Rm9yY2UpXG4gIH07XG59O1xuY29uc3QgdXNlQ29sbGlkZXJFdmVudHMgPSAoZ2V0Q29sbGlkZXIsIHByb3BzLCBldmVudHMsXG4vKipcbiAqIFRoZSBSaWdpZEJvZHkgY2FuIHBhc3MgZG93biBhY3RpdmUgZXZlbnRzIHRvIHRoZSBjb2xsaWRlciB3aXRob3V0IGF0dGFjaGluZyB0aGUgZXZlbnQgbGlzdG5lcnNcbiAqL1xuYWN0aXZlRXZlbnRzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgb25Db2xsaXNpb25FeGl0LFxuICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgIG9uQ29udGFjdEZvcmNlXG4gIH0gPSBwcm9wcztcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldENvbGxpZGVyKCk7XG5cbiAgICBpZiAoY29sbGlkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGlzaW9uOiBjb2xsaXNpb25FdmVudHNBY3RpdmUsXG4gICAgICAgIGNvbnRhY3RGb3JjZTogY29udGFjdEZvcmNlRXZlbnRzQWN0aXZlXG4gICAgICB9ID0gZ2V0QWN0aXZlQ29sbGlzaW9uRXZlbnRzRnJvbVByb3BzKHByb3BzKTtcbiAgICAgIGNvbnN0IGhhc0NvbGxpc2lvbkV2ZW50ID0gY29sbGlzaW9uRXZlbnRzQWN0aXZlIHx8IGFjdGl2ZUV2ZW50cy5jb2xsaXNpb247XG4gICAgICBjb25zdCBoYXNDb250YWN0Rm9yY2VFdmVudCA9IGNvbnRhY3RGb3JjZUV2ZW50c0FjdGl2ZSB8fCBhY3RpdmVFdmVudHMuY29udGFjdEZvcmNlO1xuXG4gICAgICBpZiAoaGFzQ29sbGlzaW9uRXZlbnQgJiYgaGFzQ29udGFjdEZvcmNlRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT0xMSVNJT05fRVZFTlRTIHwgQWN0aXZlRXZlbnRzLkNPTlRBQ1RfRk9SQ0VfRVZFTlRTKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29sbGlzaW9uRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT0xMSVNJT05fRVZFTlRTKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29udGFjdEZvcmNlRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT05UQUNUX0ZPUkNFX0VWRU5UUyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5zZXQoY29sbGlkZXIuaGFuZGxlLCB7XG4gICAgICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICAgICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICAgICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgICAgICBvbkNvbnRhY3RGb3JjZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjb2xsaWRlcikge1xuICAgICAgICBldmVudHMuZGVsZXRlKGNvbGxpZGVyLmhhbmRsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uQ29sbGlzaW9uRW50ZXIsIG9uQ29sbGlzaW9uRXhpdCwgb25JbnRlcnNlY3Rpb25FbnRlciwgb25JbnRlcnNlY3Rpb25FeGl0LCBvbkNvbnRhY3RGb3JjZSwgYWN0aXZlRXZlbnRzXSk7XG59O1xuY29uc3QgY2xlYW5SaWdpZEJvZHlQcm9wc0ZvckNvbGxpZGVyID0gKHByb3BzID0ge30pID0+IHtcbiAgY29uc3QgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDIpO1xuXG4gIHJldHVybiByZXN0O1xufTtcblxuY29uc3QgdXNlTXV0YWJsZUNhbGxiYWNrID0gZm4gPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYoZm4pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0sIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufTsgLy8gRXh0ZXJuYWwgaG9va3NcblxuLyoqXG4gKiBFeHBvc2VzIHRoZSBSYXBpZXIgY29udGV4dCwgYW5kIHdvcmxkXG4gKiBAY2F0ZWdvcnkgSG9va3NcbiAqL1xuXG5cbmNvbnN0IHVzZVJhcGllciA9ICgpID0+IHtcbiAgY29uc3QgcmFwaWVyID0gdXNlQ29udGV4dChyYXBpZXJDb250ZXh0KTtcbiAgaWYgKCFyYXBpZXIpIHRocm93IG5ldyBFcnJvcigncmVhY3QtdGhyZWUtcmFwaWVyOiB1c2VSYXBpZXIgbXVzdCBiZSB1c2VkIHdpdGhpbiA8UGh5c2ljcyAvPiEnKTtcbiAgcmV0dXJuIHJhcGllcjtcbn07XG4vKipcbiAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBiZWZvcmUgdGhlIHBoeXNpY3Mgc3RlcFxuICogQGNhdGVnb3J5IEhvb2tzXG4gKi9cblxuY29uc3QgdXNlQmVmb3JlUGh5c2ljc1N0ZXAgPSBjYWxsYmFjayA9PiB7XG4gIGNvbnN0IHtcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLmFkZChyZWYpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLmRlbGV0ZShyZWYpO1xuICAgIH07XG4gIH0sIFtdKTtcbn07XG4vKipcbiAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgcGh5c2ljcyBzdGVwXG4gKiBAY2F0ZWdvcnkgSG9va3NcbiAqL1xuXG5jb25zdCB1c2VBZnRlclBoeXNpY3NTdGVwID0gY2FsbGJhY2sgPT4ge1xuICBjb25zdCB7XG4gICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhZnRlclN0ZXBDYWxsYmFja3MuYWRkKHJlZik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrcy5kZWxldGUocmVmKTtcbiAgICB9O1xuICB9LCBbXSk7XG59OyAvLyBJbnRlcm5hbCBob29rc1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmNvbnN0IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyA9IChyZWYsIG9wdGlvbnMsIGlnbm9yZU1lc2hDb2xsaWRlcnMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IFtjb2xsaWRlclByb3BzLCBzZXRDb2xsaWRlclByb3BzXSA9IHVzZVN0YXRlKFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvYmplY3QgPSByZWYuY3VycmVudDtcblxuICAgIGlmIChvYmplY3QgJiYgb3B0aW9ucy5jb2xsaWRlcnMgIT09IGZhbHNlKSB7XG4gICAgICBzZXRDb2xsaWRlclByb3BzKGNyZWF0ZUNvbGxpZGVyUHJvcHNGcm9tQ2hpbGRyZW4oe1xuICAgICAgICBvYmplY3Q6IHJlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpZ25vcmVNZXNoQ29sbGlkZXJzXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3B0aW9ucy5jb2xsaWRlcnNdKTtcbiAgcmV0dXJuIGNvbGxpZGVyUHJvcHM7XG59O1xuXG5jb25zdCBEZWJ1ZyA9IC8qI19fUFVSRV9fKi9tZW1vKCgpID0+IHtcbiAgY29uc3Qge1xuICAgIHdvcmxkXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgY29uc3QgbWVzaCA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbWVzaCkgcmV0dXJuO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB3b3JsZC5kZWJ1Z1JlbmRlcigpO1xuICAgIG1lc2guZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXJzLnZlcnRpY2VzLCAzKSk7XG4gICAgbWVzaC5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJjb2xvclwiLCBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcnMuY29sb3JzLCA0KSk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVTZWdtZW50c1wiLCB7XG4gICAgcmVmOiByZWYsXG4gICAgZnJ1c3R1bUN1bGxlZDogZmFsc2VcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lQmFzaWNNYXRlcmlhbFwiLCB7XG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIHZlcnRleENvbG9yczogdHJ1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLCBudWxsKSkpO1xufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IHRoYXQgd2lsbCBjcmVhdGUgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNsYXNzXG4gKiB3aGVuIGEgcHJvcGVydHkgaXMgYWNjZXNzZWQsIGFuZCBub3QgYmVmb3JlLlxuICpcbiAqIEByZXR1cm5zIEEgcHJveHkgYW5kIGEgcmVzZXQgZnVuY3Rpb24sIHNvIHRoYXQgdGhlIGluc3RhbmNlIGNhbiBjcmVhdGVkIGFnYWluXG4gKi9cbmNvbnN0IGNyZWF0ZVNpbmdsZXRvblByb3h5ID0gY3JlYXRlSW5zdGFuY2UgPT4ge1xuICBsZXQgaW5zdGFuY2U7XG4gIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldChpbnN0YW5jZSwgcHJvcCk7XG4gICAgfSxcblxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KGluc3RhbmNlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuXG4gIH07XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCBoYW5kbGVyKTtcblxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBpbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcHJveHkgYW5kIGEgcmVzZXQgZnVuY3Rpb25cbiAgICovXG5cblxuICByZXR1cm4ge1xuICAgIHByb3h5LFxuICAgIHJlc2V0XG4gIH07XG59O1xuXG5jb25zdCByYXBpZXJDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuY29uc3QgZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2UgPSAodGFyZ2V0LCBvdGhlcikgPT4ge1xuICB2YXIgX3RhcmdldCRjb2xsaWRlciRzdGF0LCBfdGFyZ2V0JHJpZ2lkQm9keSRzdGEsIF9vdGhlciRjb2xsaWRlciRzdGF0ZSwgX290aGVyJHJpZ2lkQm9keSRzdGF0LCBfb3RoZXIkY29sbGlkZXIkc3RhdGUyLCBfb3RoZXIkcmlnaWRCb2R5JHN0YXQyO1xuXG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB7XG4gICAgICByaWdpZEJvZHk6IHRhcmdldC5yaWdpZEJvZHkub2JqZWN0LFxuICAgICAgY29sbGlkZXI6IHRhcmdldC5jb2xsaWRlci5vYmplY3QsXG4gICAgICBjb2xsaWRlck9iamVjdDogKF90YXJnZXQkY29sbGlkZXIkc3RhdCA9IHRhcmdldC5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX3RhcmdldCRjb2xsaWRlciRzdGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0JGNvbGxpZGVyJHN0YXQub2JqZWN0LFxuICAgICAgcmlnaWRCb2R5T2JqZWN0OiAoX3RhcmdldCRyaWdpZEJvZHkkc3RhID0gdGFyZ2V0LnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX3RhcmdldCRyaWdpZEJvZHkkc3RhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0JHJpZ2lkQm9keSRzdGEub2JqZWN0XG4gICAgfSxcbiAgICBvdGhlcjoge1xuICAgICAgcmlnaWRCb2R5OiBvdGhlci5yaWdpZEJvZHkub2JqZWN0LFxuICAgICAgY29sbGlkZXI6IG90aGVyLmNvbGxpZGVyLm9iamVjdCxcbiAgICAgIGNvbGxpZGVyT2JqZWN0OiAoX290aGVyJGNvbGxpZGVyJHN0YXRlID0gb3RoZXIuY29sbGlkZXIuc3RhdGUpID09PSBudWxsIHx8IF9vdGhlciRjb2xsaWRlciRzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJGNvbGxpZGVyJHN0YXRlLm9iamVjdCxcbiAgICAgIHJpZ2lkQm9keU9iamVjdDogKF9vdGhlciRyaWdpZEJvZHkkc3RhdCA9IG90aGVyLnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJHJpZ2lkQm9keSRzdGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3RoZXIkcmlnaWRCb2R5JHN0YXQub2JqZWN0XG4gICAgfSxcbiAgICByaWdpZEJvZHk6IG90aGVyLnJpZ2lkQm9keS5vYmplY3QsXG4gICAgY29sbGlkZXI6IG90aGVyLmNvbGxpZGVyLm9iamVjdCxcbiAgICBjb2xsaWRlck9iamVjdDogKF9vdGhlciRjb2xsaWRlciRzdGF0ZTIgPSBvdGhlci5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJGNvbGxpZGVyJHN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJGNvbGxpZGVyJHN0YXRlMi5vYmplY3QsXG4gICAgcmlnaWRCb2R5T2JqZWN0OiAoX290aGVyJHJpZ2lkQm9keSRzdGF0MiA9IG90aGVyLnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJHJpZ2lkQm9keSRzdGF0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJHJpZ2lkQm9keSRzdGF0Mi5vYmplY3RcbiAgfTtcbn07XG5cbmNvbnN0IGltcG9ydFJhcGllciA9IGFzeW5jICgpID0+IHtcbiAgbGV0IHIgPSBhd2FpdCBpbXBvcnQoJ0BkaW1mb3JnZS9yYXBpZXIzZC1jb21wYXQnKTtcbiAgYXdhaXQgci5pbml0KCk7XG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBwaHlzaWNzIGNvbXBvbmVudCB1c2VkIHRvIGNyZWF0ZSBhIHBoeXNpY3Mgd29ybGQuXG4gKiBAY2F0ZWdvcnkgQ29tcG9uZW50c1xuICovXG5jb25zdCBQaHlzaWNzID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY29sbGlkZXJzID0gXCJjdWJvaWRcIixcbiAgICBjaGlsZHJlbixcbiAgICB0aW1lU3RlcCA9IDEgLyA2MCxcbiAgICBwYXVzZWQgPSBmYWxzZSxcbiAgICBpbnRlcnBvbGF0ZSA9IHRydWUsXG4gICAgdXBkYXRlUHJpb3JpdHksXG4gICAgdXBkYXRlTG9vcCA9IFwiZm9sbG93XCIsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgICBncmF2aXR5ID0gWzAsIC05LjgxLCAwXSxcbiAgICBtYXhTdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDEsXG4gICAgbWF4VmVsb2NpdHlGcmljdGlvbkl0ZXJhdGlvbnMgPSA4LFxuICAgIG1heFZlbG9jaXR5SXRlcmF0aW9ucyA9IDQsXG4gICAgcHJlZGljdGlvbkRpc3RhbmNlID0gMC4wMDIsXG4gICAgZXJwID0gMC44XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcmFwaWVyID0gdXNlQXNzZXQoaW1wb3J0UmFwaWVyKTtcbiAgY29uc3Qge1xuICAgIGludmFsaWRhdGVcbiAgfSA9IHVzZVRocmVlKCk7XG4gIGNvbnN0IHJpZ2lkQm9keVN0YXRlcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IGNvbGxpZGVyU3RhdGVzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgcmlnaWRCb2R5RXZlbnRzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgY29sbGlkZXJFdmVudHMgPSB1c2VDb25zdCgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBldmVudFF1ZXVlID0gdXNlQ29uc3QoKCkgPT4gbmV3IEV2ZW50UXVldWUoZmFsc2UpKTtcbiAgY29uc3QgYmVmb3JlU3RlcENhbGxiYWNrcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBTZXQoKSk7XG4gIGNvbnN0IGFmdGVyU3RlcENhbGxiYWNrcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBTZXQoKSk7XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB0aGUgd29ybGRcbiAgICogVGhpcyBjcmVhdGVzIGEgc2luZ2xldG9uIHByb3h5LCBzbyB0aGF0IHRoZSB3b3JsZCBpcyBvbmx5IGNyZWF0ZWQgd2hlblxuICAgKiBzb21ldGhpbmcgd2l0aGluIGl0IGlzIGFjY2Vzc2VkLlxuICAgKi9cblxuICBjb25zdCB7XG4gICAgcHJveHk6IHdvcmxkUHJveHksXG4gICAgcmVzZXQ6IHJlc2V0V29ybGRQcm94eVxuICB9ID0gdXNlQ29uc3QoKCkgPT4gY3JlYXRlU2luZ2xldG9uUHJveHkoKCkgPT4gbmV3IHJhcGllci5Xb3JsZCh2ZWN0b3JBcnJheVRvVmVjdG9yMyhncmF2aXR5KSkpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd29ybGRQcm94eS5mcmVlKCk7XG4gICAgICByZXNldFdvcmxkUHJveHkoKTtcbiAgICB9O1xuICB9LCBbXSk7IC8vIFVwZGF0ZSBtdXRhYmxlIHByb3BzXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB3b3JsZFByb3h5LmdyYXZpdHkgPSB2ZWN0b3JBcnJheVRvVmVjdG9yMyhncmF2aXR5KTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5tYXhTdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IG1heFN0YWJpbGl6YXRpb25JdGVyYXRpb25zO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm1heFZlbG9jaXR5RnJpY3Rpb25JdGVyYXRpb25zID0gbWF4VmVsb2NpdHlGcmljdGlvbkl0ZXJhdGlvbnM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubWF4VmVsb2NpdHlJdGVyYXRpb25zID0gbWF4VmVsb2NpdHlJdGVyYXRpb25zO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLnByZWRpY3Rpb25EaXN0YW5jZSA9IHByZWRpY3Rpb25EaXN0YW5jZTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5lcnAgPSBlcnA7XG4gIH0sIFt3b3JsZFByb3h5LCAuLi5ncmF2aXR5LCBtYXhTdGFiaWxpemF0aW9uSXRlcmF0aW9ucywgbWF4VmVsb2NpdHlJdGVyYXRpb25zLCBtYXhWZWxvY2l0eUZyaWN0aW9uSXRlcmF0aW9ucywgcHJlZGljdGlvbkRpc3RhbmNlLCBlcnBdKTtcbiAgY29uc3QgZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlID0gdXNlQ2FsbGJhY2soaGFuZGxlID0+IHtcbiAgICB2YXIgX2NvbGxpZGVyJHBhcmVudDtcblxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGRQcm94eS5nZXRDb2xsaWRlcihoYW5kbGUpO1xuICAgIGNvbnN0IGNvbEV2ZW50cyA9IGNvbGxpZGVyRXZlbnRzLmdldChoYW5kbGUpO1xuICAgIGNvbnN0IGNvbGxpZGVyU3RhdGUgPSBjb2xsaWRlclN0YXRlcy5nZXQoaGFuZGxlKTtcbiAgICBjb25zdCByaWdpZEJvZHlIYW5kbGUgPSBjb2xsaWRlciA9PT0gbnVsbCB8fCBjb2xsaWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2xsaWRlciRwYXJlbnQgPSBjb2xsaWRlci5wYXJlbnQoKSkgPT09IG51bGwgfHwgX2NvbGxpZGVyJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxpZGVyJHBhcmVudC5oYW5kbGU7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gcmlnaWRCb2R5SGFuZGxlICE9PSB1bmRlZmluZWQgPyB3b3JsZFByb3h5LmdldFJpZ2lkQm9keShyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJiRXZlbnRzID0gcmlnaWRCb2R5ICYmIHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gcmlnaWRCb2R5RXZlbnRzLmdldChyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJpZ2lkQm9keVN0YXRlID0gcmlnaWRCb2R5SGFuZGxlICE9PSB1bmRlZmluZWQgPyByaWdpZEJvZHlTdGF0ZXMuZ2V0KHJpZ2lkQm9keUhhbmRsZSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgY29sbGlkZXI6IHtcbiAgICAgICAgb2JqZWN0OiBjb2xsaWRlcixcbiAgICAgICAgZXZlbnRzOiBjb2xFdmVudHMsXG4gICAgICAgIHN0YXRlOiBjb2xsaWRlclN0YXRlXG4gICAgICB9LFxuICAgICAgcmlnaWRCb2R5OiB7XG4gICAgICAgIG9iamVjdDogcmlnaWRCb2R5LFxuICAgICAgICBldmVudHM6IHJiRXZlbnRzLFxuICAgICAgICBzdGF0ZTogcmlnaWRCb2R5U3RhdGVcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sIFtdKTtcbiAgY29uc3QgW3N0ZXBwaW5nU3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIHByZXZpb3VzU3RhdGU6IHt9LFxuICAgIGFjY3VtdWxhdG9yOiAwXG4gIH0pO1xuICBjb25zdCBzdGVwID0gdXNlQ2FsbGJhY2soZHQgPT4ge1xuICAgIGNvbnN0IHdvcmxkID0gd29ybGRQcm94eTtcbiAgICAvKiBDaGVjayBpZiB0aGUgdGltZXN0ZXAgaXMgc3VwcG9zZWQgdG8gYmUgdmFyaWFibGUuIFdlJ2xsIGRvIHRoaXMgaGVyZVxuICAgICAgb25jZSBzbyB3ZSBkb24ndCBoYXZlIHRvIHN0cmluZy1jaGVjayBldmVyeSBmcmFtZS4gKi9cblxuICAgIGNvbnN0IHRpbWVTdGVwVmFyaWFibGUgPSB0aW1lU3RlcCA9PT0gXCJ2YXJ5XCI7XG4gICAgLyoqXG4gICAgICogRml4ZWQgdGltZVN0ZXAgc2ltdWxhdGlvbiBwcm9ncmVzc2lvblxuICAgICAqIEBzZWUgaHR0cHM6Ly9nYWZmZXJvbmdhbWVzLmNvbS9wb3N0L2ZpeF95b3VyX3RpbWVzdGVwL1xuICAgICAqL1xuXG4gICAgY29uc3QgY2xhbXBlZERlbHRhID0gTWF0aFV0aWxzLmNsYW1wKGR0LCAwLCAwLjUpO1xuXG4gICAgY29uc3Qgc3RlcFdvcmxkID0gZGVsdGEgPT4ge1xuICAgICAgLy8gVHJpZ2dlciBiZWZvcmVTdGVwIGNhbGxiYWNrc1xuICAgICAgYmVmb3JlU3RlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2suY3VycmVudCh3b3JsZCk7XG4gICAgICB9KTtcbiAgICAgIHdvcmxkLnRpbWVzdGVwID0gZGVsdGE7XG4gICAgICB3b3JsZC5zdGVwKGV2ZW50UXVldWUpOyAvLyBUcmlnZ2VyIGFmdGVyU3RlcCBjYWxsYmFja3NcblxuICAgICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICBjYWxsYmFjay5jdXJyZW50KHdvcmxkKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAodGltZVN0ZXBWYXJpYWJsZSkge1xuICAgICAgc3RlcFdvcmxkKGNsYW1wZWREZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvbid0IHN0ZXAgdGltZSBmb3J3YXJkcyBpZiBwYXVzZWRcbiAgICAgIC8vIEluY3JlYXNlIGFjY3VtdWxhdG9yXG4gICAgICBzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yICs9IGNsYW1wZWREZWx0YTtcblxuICAgICAgd2hpbGUgKHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgPj0gdGltZVN0ZXApIHtcbiAgICAgICAgLy8gU2V0IHVwIHByZXZpb3VzIHN0YXRlXG4gICAgICAgIC8vIG5lZWRlZCBmb3IgYWNjdXJhdGUgaW50ZXJwb2xhdGlvbnMgaWYgdGhlIHdvcmxkIHN0ZXBzIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICAgIHN0ZXBwaW5nU3RhdGUucHJldmlvdXNTdGF0ZSA9IHt9O1xuICAgICAgICAgIHdvcmxkLmZvckVhY2hSaWdpZEJvZHkoYm9keSA9PiB7XG4gICAgICAgICAgICBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGVbYm9keS5oYW5kbGVdID0ge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogYm9keS50cmFuc2xhdGlvbigpLFxuICAgICAgICAgICAgICByb3RhdGlvbjogYm9keS5yb3RhdGlvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RlcFdvcmxkKHRpbWVTdGVwKTtcbiAgICAgICAgc3RlcHBpbmdTdGF0ZS5hY2N1bXVsYXRvciAtPSB0aW1lU3RlcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uQWxwaGEgPSB0aW1lU3RlcFZhcmlhYmxlIHx8ICFpbnRlcnBvbGF0ZSB8fCBwYXVzZWQgPyAxIDogc3RlcHBpbmdTdGF0ZS5hY2N1bXVsYXRvciAvIHRpbWVTdGVwOyAvLyBVcGRhdGUgbWVzaGVzXG5cbiAgICByaWdpZEJvZHlTdGF0ZXMuZm9yRWFjaCgoc3RhdGUsIGhhbmRsZSkgPT4ge1xuICAgICAgY29uc3QgcmlnaWRCb2R5ID0gd29ybGQuZ2V0UmlnaWRCb2R5KGhhbmRsZSk7XG4gICAgICBjb25zdCBldmVudHMgPSByaWdpZEJvZHlFdmVudHMuZ2V0KGhhbmRsZSk7XG5cbiAgICAgIGlmIChldmVudHMgIT09IG51bGwgJiYgZXZlbnRzICE9PSB2b2lkIDAgJiYgZXZlbnRzLm9uU2xlZXAgfHwgZXZlbnRzICE9PSBudWxsICYmIGV2ZW50cyAhPT0gdm9pZCAwICYmIGV2ZW50cy5vbldha2UpIHtcbiAgICAgICAgaWYgKHJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50cyRvblNsZWVwO1xuXG4gICAgICAgICAgZXZlbnRzID09PSBudWxsIHx8IGV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudHMkb25TbGVlcCA9IGV2ZW50cy5vblNsZWVwKSA9PT0gbnVsbCB8fCBfZXZlbnRzJG9uU2xlZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudHMkb25TbGVlcC5jYWxsKGV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgc3RhdGUuaXNTbGVlcGluZykge1xuICAgICAgICAgIHZhciBfZXZlbnRzJG9uV2FrZTtcblxuICAgICAgICAgIGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnRzJG9uV2FrZSA9IGV2ZW50cy5vbldha2UpID09PSBudWxsIHx8IF9ldmVudHMkb25XYWtlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnRzJG9uV2FrZS5jYWxsKGV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gcmlnaWRCb2R5LmlzU2xlZXBpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyaWdpZEJvZHkgfHwgcmlnaWRCb2R5LmlzU2xlZXBpbmcoKSAmJiAhKFwiaXNJbnN0YW5jZWRNZXNoXCIgaW4gc3RhdGUub2JqZWN0KSB8fCAhc3RhdGUuc2V0TWF0cml4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gTmV3IHN0YXRlc1xuXG5cbiAgICAgIGxldCB0ID0gcmlnaWRCb2R5LnRyYW5zbGF0aW9uKCk7XG4gICAgICBsZXQgciA9IHJpZ2lkQm9keS5yb3RhdGlvbigpO1xuICAgICAgbGV0IHByZXZpb3VzU3RhdGUgPSBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGVbaGFuZGxlXTtcblxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUpIHtcbiAgICAgICAgLy8gR2V0IHByZXZpb3VzIHNpbXVsYXRlZCB3b3JsZCBwb3NpdGlvblxuICAgICAgICBfbWF0cml4NC5jb21wb3NlKHByZXZpb3VzU3RhdGUucG9zaXRpb24sIHJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24ocHJldmlvdXNTdGF0ZS5yb3RhdGlvbiksIHN0YXRlLnNjYWxlKS5wcmVtdWx0aXBseShzdGF0ZS5pbnZlcnRlZFdvcmxkTWF0cml4KS5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7IC8vIEFwcGx5IHByZXZpb3VzIHRpY2sgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChzdGF0ZS5tZXNoVHlwZSA9PSBcIm1lc2hcIikge1xuICAgICAgICAgIHN0YXRlLm9iamVjdC5wb3NpdGlvbi5jb3B5KF9wb3NpdGlvbik7XG4gICAgICAgICAgc3RhdGUub2JqZWN0LnF1YXRlcm5pb24uY29weShfcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCBuZXcgcG9zaXRpb25cblxuXG4gICAgICBfbWF0cml4NC5jb21wb3NlKHQsIHJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24ociksIHN0YXRlLnNjYWxlKS5wcmVtdWx0aXBseShzdGF0ZS5pbnZlcnRlZFdvcmxkTWF0cml4KS5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5tZXNoVHlwZSA9PSBcImluc3RhbmNlZE1lc2hcIikge1xuICAgICAgICBzdGF0ZS5zZXRNYXRyaXgoX21hdHJpeDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gbmV3IHBvc2l0aW9uXG4gICAgICAgIHN0YXRlLm9iamVjdC5wb3NpdGlvbi5sZXJwKF9wb3NpdGlvbiwgaW50ZXJwb2xhdGlvbkFscGhhKTtcbiAgICAgICAgc3RhdGUub2JqZWN0LnF1YXRlcm5pb24uc2xlcnAoX3JvdGF0aW9uLCBpbnRlcnBvbGF0aW9uQWxwaGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV2ZW50UXVldWUuZHJhaW5Db2xsaXNpb25FdmVudHMoKGhhbmRsZTEsIGhhbmRsZTIsIHN0YXJ0ZWQpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZTEgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoaGFuZGxlMSk7XG4gICAgICBjb25zdCBzb3VyY2UyID0gZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlKGhhbmRsZTIpOyAvLyBDb2xsaXNpb24gRXZlbnRzXG5cbiAgICAgIGlmICghKHNvdXJjZTEgIT09IG51bGwgJiYgc291cmNlMSAhPT0gdm9pZCAwICYmIHNvdXJjZTEuY29sbGlkZXIub2JqZWN0KSB8fCAhKHNvdXJjZTIgIT09IG51bGwgJiYgc291cmNlMiAhPT0gdm9pZCAwICYmIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQxID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMSwgc291cmNlMik7XG4gICAgICBjb25zdCBjb2xsaXNpb25QYXlsb2FkMiA9IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlKHNvdXJjZTIsIHNvdXJjZTEpO1xuXG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICB3b3JsZC5jb250YWN0UGFpcihzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCwgc291cmNlMi5jb2xsaWRlci5vYmplY3QsIChtYW5pZm9sZCwgZmxpcHBlZCkgPT4ge1xuICAgICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXYsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjIsIF9zb3VyY2UyJHJpZ2lkQm9keSRldiwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MiwgX3NvdXJjZTEkY29sbGlkZXIkZXZlLCBfc291cmNlMSRjb2xsaWRlciRldmUyLCBfc291cmNlMiRjb2xsaWRlciRldmUsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTI7XG5cbiAgICAgICAgICAvKiBSaWdpZEJvZHkgZXZlbnRzICovXG4gICAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldiA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MiA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldi5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXYyLmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXYgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjIgPSBfc291cmNlMiRyaWdpZEJvZHkkZXYub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2Mi5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAvKiBDb2xsaWRlciBldmVudHMgKi9cblxuICAgICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmUgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlMiA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZS5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmUyLmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmUgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlMiA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZS5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmUyLmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDIpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXYzLCBfc291cmNlMSRyaWdpZEJvZHkkZXY0LCBfc291cmNlMiRyaWdpZEJvZHkkZXYzLCBfc291cmNlMiRyaWdpZEJvZHkkZXY0LCBfc291cmNlMSRjb2xsaWRlciRldmUzLCBfc291cmNlMSRjb2xsaWRlciRldmU0LCBfc291cmNlMiRjb2xsaWRlciRldmUzLCBfc291cmNlMiRjb2xsaWRlciRldmU0O1xuXG4gICAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXYzID0gc291cmNlMS5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldjMub25Db2xsaXNpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXY0LmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MywgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2MyA9IHNvdXJjZTIucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjQgPSBfc291cmNlMiRyaWdpZEJvZHkkZXYzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2NC5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjMsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQgPSBfc291cmNlMSRjb2xsaWRlciRldmUzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlNC5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTQgPSBfc291cmNlMiRjb2xsaWRlciRldmUzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlNC5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgIH0gLy8gU2Vuc29yIEludGVyc2VjdGlvbnNcblxuXG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICBpZiAod29ybGQuaW50ZXJzZWN0aW9uUGFpcihzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCwgc291cmNlMi5jb2xsaWRlci5vYmplY3QpKSB7XG4gICAgICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldjUsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjYsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjUsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjYsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTY7XG5cbiAgICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NSA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjYgPSBfc291cmNlMSRyaWdpZEJvZHkkZXY1Lm9uSW50ZXJzZWN0aW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjYuY2FsbChfc291cmNlMSRyaWdpZEJvZHkkZXY1LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjUgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY2ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2NS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXY2LmNhbGwoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NSwgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU1ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU2ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlNS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmU2LmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlNSwgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU1ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU2ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlNS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmU2LmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlNSwgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NywgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OCwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NywgX3NvdXJjZTIkcmlnaWRCb2R5JGV2OCwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNywgX3NvdXJjZTEkY29sbGlkZXIkZXZlOCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNywgX3NvdXJjZTIkY29sbGlkZXIkZXZlODtcblxuICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NyA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjggPSBfc291cmNlMSRyaWdpZEJvZHkkZXY3Lm9uSW50ZXJzZWN0aW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2OC5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjcsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjcgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY4ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2Ny5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjguY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXY3LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU3ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU4ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlNy5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTguY2FsbChfc291cmNlMSRjb2xsaWRlciRldmU3LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU3ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU4ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlNy5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTguY2FsbChfc291cmNlMiRjb2xsaWRlciRldmU3LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXZlbnRRdWV1ZS5kcmFpbkNvbnRhY3RGb3JjZUV2ZW50cyhldmVudCA9PiB7XG4gICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjksIF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwLCBfc291cmNlMSRjb2xsaWRlciRldmU5LCBfc291cmNlMSRjb2xsaWRlciRldmUxMCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlOSwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMTA7XG5cbiAgICAgIGNvbnN0IHNvdXJjZTEgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoZXZlbnQuY29sbGlkZXIxKCkpO1xuICAgICAgY29uc3Qgc291cmNlMiA9IGdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZShldmVudC5jb2xsaWRlcjIoKSk7IC8vIENvbGxpc2lvbiBFdmVudHNcblxuICAgICAgaWYgKCEoc291cmNlMSAhPT0gbnVsbCAmJiBzb3VyY2UxICE9PSB2b2lkIDAgJiYgc291cmNlMS5jb2xsaWRlci5vYmplY3QpIHx8ICEoc291cmNlMiAhPT0gbnVsbCAmJiBzb3VyY2UyICE9PSB2b2lkIDAgJiYgc291cmNlMi5jb2xsaWRlci5vYmplY3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDEgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UxLCBzb3VyY2UyKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQyID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMiwgc291cmNlMSk7XG4gICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2OS5vbkNvbnRhY3RGb3JjZSkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwLmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgdG90YWxGb3JjZTogZXZlbnQudG90YWxGb3JjZSgpLFxuICAgICAgICB0b3RhbEZvcmNlTWFnbml0dWRlOiBldmVudC50b3RhbEZvcmNlTWFnbml0dWRlKCksXG4gICAgICAgIG1heEZvcmNlRGlyZWN0aW9uOiBldmVudC5tYXhGb3JjZURpcmVjdGlvbigpLFxuICAgICAgICBtYXhGb3JjZU1hZ25pdHVkZTogZXZlbnQubWF4Rm9yY2VNYWduaXR1ZGUoKVxuICAgICAgfSkpO1xuICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjkgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXYxMCA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXYxMC5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU5ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmUxMCA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmUxMC5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMSksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU5ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmUxMCA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmUxMC5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB3b3JsZC5mb3JFYWNoQWN0aXZlUmlnaWRCb2R5KCgpID0+IHtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICB9KTtcbiAgfSwgW3BhdXNlZCwgdGltZVN0ZXAsIGludGVycG9sYXRlLCB3b3JsZFByb3h5XSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmFwaWVyLFxuICAgIHdvcmxkOiB3b3JsZFByb3h5LFxuICAgIHBoeXNpY3NPcHRpb25zOiB7XG4gICAgICBjb2xsaWRlcnMsXG4gICAgICBncmF2aXR5XG4gICAgfSxcbiAgICByaWdpZEJvZHlTdGF0ZXMsXG4gICAgY29sbGlkZXJTdGF0ZXMsXG4gICAgcmlnaWRCb2R5RXZlbnRzLFxuICAgIGNvbGxpZGVyRXZlbnRzLFxuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MsXG4gICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLFxuICAgIGlzUGF1c2VkOiBwYXVzZWQsXG4gICAgaXNEZWJ1ZzogZGVidWcsXG4gICAgc3RlcFxuICB9KSwgW3BhdXNlZCwgc3RlcCwgZGVidWcsIGNvbGxpZGVycywgZ3Jhdml0eV0pO1xuICBjb25zdCBzdGVwQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhkZWx0YSA9PiB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHN0ZXAoZGVsdGEpO1xuICAgIH1cbiAgfSwgW3BhdXNlZCwgc3RlcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocmFwaWVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZyYW1lU3RlcHBlciQxLCB7XG4gICAgb25TdGVwOiBzdGVwQ2FsbGJhY2ssXG4gICAgdHlwZTogdXBkYXRlTG9vcCxcbiAgICB1cGRhdGVQcmlvcml0eTogdXBkYXRlUHJpb3JpdHlcbiAgfSksIGRlYnVnICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlYnVnLCBudWxsKSwgY2hpbGRyZW4pO1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIGFuIGluc3RhbmNlIGFuZCByZXR1cm4gYSBzYWZlIGdldHRlclxuICovXG5cbmNvbnN0IHVzZUltcGVyYXRpdmVJbnN0YW5jZSA9IChjcmVhdGVGbiwgZGVzdHJveUZuLCBkZXBlbmRlbmN5TGlzdCkgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgZ2V0SW5zdGFuY2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgcmVmLmN1cnJlbnQgPSBjcmVhdGVGbigpO1xuICAgIH1cblxuICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgfSwgZGVwZW5kZW5jeUxpc3QpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNhdmUgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gYW5kIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRJbnN0YW5jZSgpO1xuXG4gICAgY29uc3QgZGVzdHJveSA9ICgpID0+IGRlc3Ryb3lGbihpbnN0YW5jZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVzdHJveSgpO1xuICAgICAgcmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSwgW2dldEluc3RhbmNlXSk7XG4gIHJldHVybiBnZXRJbnN0YW5jZTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHJlc2VtYmxpbmcgYSBWZWN0b3IzIGFuZCByZXR1cnMgYSBUaHJlZS5WZWN0b3IzXG4gKiBAY2F0ZWdvcnkgTWF0aCBoZWxwZXJzXG4gKi9cblxuY29uc3QgdmVjMyA9ICh7XG4gIHgsXG4gIHksXG4gIHpcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDBcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xufTtcbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHJlc2VtYmxpbmcgYSBRdWF0ZXJuaW9uIGFuZCByZXR1cnMgYSBUaHJlZS5RdWF0ZXJuaW9uXG4gKiBAY2F0ZWdvcnkgTWF0aCBoZWxwZXJzXG4gKi9cblxuY29uc3QgcXVhdCA9ICh7XG4gIHgsXG4gIHksXG4gIHosXG4gIHdcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDAsXG4gIHc6IDFcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHgsIHksIHosIHcpO1xufTtcbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHJlc2VtYmxpbmcgYW4gRXVsZXIgYW5kIHJldHVycyBhIFRocmVlLkV1bGVyXG4gKiBAY2F0ZWdvcnkgTWF0aCBoZWxwZXJzXG4gKi9cblxuY29uc3QgZXVsZXIgPSAoe1xuICB4LFxuICB5LFxuICB6XG59ID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6OiAwXG59KSA9PiB7XG4gIHJldHVybiBuZXcgRXVsZXIoeCwgeSwgeik7XG59O1xuXG5jb25zdCB1c2VGb3J3YXJkZWRSZWYgPSAoZm9yd2FyZGVkUmVmLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGlubmVyUmVmID0gdXNlUmVmKGRlZmF1bHRWYWx1ZSk7IC8vIFVwZGF0ZSB0aGUgZm9yd2FyZGVkIHJlZiB3aGVuIHRoZSBpbm5lciByZWYgY2hhbmdlc1xuXG4gIGlmIChmb3J3YXJkZWRSZWYgJiYgdHlwZW9mIGZvcndhcmRlZFJlZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKCFmb3J3YXJkZWRSZWYuY3VycmVudCkge1xuICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbm5lclJlZi5jdXJyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmb3J3YXJkZWRSZWY7XG4gIH1cblxuICByZXR1cm4gaW5uZXJSZWY7XG59O1xuXG4vKipcbiAqIEEgY29sbGlkZXIgaXMgYSBzaGFwZSB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHJpZ2lkIGJvZHkgdG8gZGVmaW5lIGl0cyBwaHlzaWNhbCBwcm9wZXJ0aWVzLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFueUNvbGxpZGVyID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBwb3NpdGlvbixcbiAgICByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlLFxuICAgIG5hbWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgd29ybGQsXG4gICAgY29sbGlkZXJFdmVudHMsXG4gICAgY29sbGlkZXJTdGF0ZXNcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByaWdpZEJvZHlDb250ZXh0ID0gdXNlUmlnaWRCb2R5Q29udGV4dCgpO1xuICBjb25zdCBjb2xsaWRlclJlZiA9IHVzZUZvcndhcmRlZFJlZihmb3J3YXJkZWRSZWYpO1xuICBjb25zdCBvYmplY3RSZWYgPSB1c2VSZWYobnVsbCk7IC8vIFdlIHNwcmVhZCB0aGUgcHJvcHMgb3V0IGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZiBpcyB1cGRhdGVkIHdoZW4gdGhlIHByb3BzIGNoYW5nZS5cblxuICBjb25zdCBpbW11dGFibGVQcm9wQXJyYXkgPSBpbW11dGFibGVDb2xsaWRlck9wdGlvbnMuZmxhdE1hcChrZXkgPT4gQXJyYXkuaXNBcnJheShwcm9wc1trZXldKSA/IFsuLi5wcm9wc1trZXldXSA6IHByb3BzW2tleV0pO1xuICBjb25zdCBnZXRJbnN0YW5jZSA9IHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgY29uc3Qgd29ybGRTY2FsZSA9IG9iamVjdFJlZi5jdXJyZW50LmdldFdvcmxkU2NhbGUodmVjMygpKTtcbiAgICBjb25zdCBjb2xsaWRlciA9IGNyZWF0ZUNvbGxpZGVyRnJvbU9wdGlvbnMocHJvcHMsIHdvcmxkLCB3b3JsZFNjYWxlLCByaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQuZ2V0UmlnaWRCb2R5KTtcblxuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yd2FyZGVkUmVmKGNvbGxpZGVyKTtcbiAgICB9XG5cbiAgICBjb2xsaWRlclJlZi5jdXJyZW50ID0gY29sbGlkZXI7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9LCBjb2xsaWRlciA9PiB7XG4gICAgaWYgKHdvcmxkLmdldENvbGxpZGVyKGNvbGxpZGVyLmhhbmRsZSkpIHtcbiAgICAgIHdvcmxkLnJlbW92ZUNvbGxpZGVyKGNvbGxpZGVyLCB0cnVlKTtcbiAgICB9XG4gIH0sIFsuLi5pbW11dGFibGVQcm9wQXJyYXksIHJpZ2lkQm9keUNvbnRleHRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldEluc3RhbmNlKCk7XG4gICAgY29sbGlkZXJTdGF0ZXMuc2V0KGNvbGxpZGVyLmhhbmRsZSwgY3JlYXRlQ29sbGlkZXJTdGF0ZShjb2xsaWRlciwgb2JqZWN0UmVmLmN1cnJlbnQsIHJpZ2lkQm9keUNvbnRleHQgPT09IG51bGwgfHwgcmlnaWRCb2R5Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaWRCb2R5Q29udGV4dC5yZWYuY3VycmVudCkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb2xsaWRlclN0YXRlcy5kZWxldGUoY29sbGlkZXIuaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbZ2V0SW5zdGFuY2VdKTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlcihyaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQub3B0aW9ucykpLCBwcm9wcyk7XG4gIH0sIFtwcm9wcywgcmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnNdKTtcbiAgdXNlVXBkYXRlQ29sbGlkZXJPcHRpb25zKGdldEluc3RhbmNlLCBtZXJnZWRQcm9wcywgY29sbGlkZXJTdGF0ZXMpO1xuICB1c2VDb2xsaWRlckV2ZW50cyhnZXRJbnN0YW5jZSwgbWVyZ2VkUHJvcHMsIGNvbGxpZGVyRXZlbnRzLCBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMocmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnMpKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgcmVmOiBvYmplY3RSZWYsXG4gICAgbmFtZTogbmFtZVxuICB9LCBjaGlsZHJlbik7XG59KSk7XG5cbi8qKlxuICogQSBjdWJvaWQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ3Vib2lkQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHNoYXBlOiBcImN1Ym9pZFwiLFxuICAgIHJlZjogcmVmXG4gIH0pKTtcbn0pO1xuQ3Vib2lkQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkN1Ym9pZENvbGxpZGVyXCI7XG5cbi8qKlxuICogQSByb3VuZCBjdWJvaWQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgUm91bmRDdWJvaWRDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInJvdW5kQ3Vib2lkXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuUm91bmRDdWJvaWRDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiUm91bmRDdWJvaWRDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgYmFsbCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBCYWxsQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJiYWxsXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQmFsbENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJCYWxsQ29sbGlkZXJcIjtcblxuLyoqXG4gKiBBIGNhcHN1bGUgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ2Fwc3VsZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY2Fwc3VsZVwiLFxuICByZWY6IHJlZlxufSkpKTtcbkNhcHN1bGVDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ2Fwc3VsZUNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBoZWlnaHRmaWVsZCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBIZWlnaHRmaWVsZENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiaGVpZ2h0ZmllbGRcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5IZWlnaHRmaWVsZENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJIZWlnaHRmaWVsZENvbGxpZGVyXCI7XG5cbi8qKlxuICogQSB0cmltZXNoIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFRyaW1lc2hDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInRyaW1lc2hcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5UcmltZXNoQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlRyaW1lc2hDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgY29uZSBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDb25lQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjb25lXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ29uZUNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDb25lQ29sbGlkZXJcIjtcblxuLyoqXG4gKiBBIHJvdW5kIGN5bGluZGVyIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFJvdW5kQ29uZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwicm91bmRDb25lXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuUm91bmRDb25lQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlJvdW5kQ29uZUNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDeWxpbmRlckNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY3lsaW5kZXJcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5DeWxpbmRlckNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDeWxpbmRlckNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSByb3VuZCBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBSb3VuZEN5bGluZGVyQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJyb3VuZEN5bGluZGVyXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ3lsaW5kZXJDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiUm91bmRDeWxpbmRlckNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBjb252ZXggaHVsbCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDb252ZXhIdWxsQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjb252ZXhIdWxsXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ29udmV4SHVsbENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDb252ZXhIdWxsQ29sbGlkZXJcIjtcblxuY29uc3QgcmlnaWRCb2R5RGVzY0Zyb21PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIHZhciBfb3B0aW9ucyRjYW5TbGVlcDtcblxuICBjb25zdCB0eXBlID0gcmlnaWRCb2R5VHlwZUZyb21TdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50eXBlKSB8fCBcImR5bmFtaWNcIik7XG4gIGNvbnN0IGRlc2MgPSBuZXcgUmlnaWRCb2R5RGVzYyh0eXBlKTsgLy8gQXBwbHkgaW1tdXRhYmxlIG9wdGlvbnNcblxuICBkZXNjLmNhblNsZWVwID0gKF9vcHRpb25zJGNhblNsZWVwID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhblNsZWVwKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYW5TbGVlcCAhPT0gdm9pZCAwID8gX29wdGlvbnMkY2FuU2xlZXAgOiB0cnVlO1xuICByZXR1cm4gZGVzYztcbn07XG5jb25zdCBjcmVhdGVSaWdpZEJvZHlTdGF0ZSA9ICh7XG4gIHJpZ2lkQm9keSxcbiAgb2JqZWN0LFxuICBzZXRNYXRyaXgsXG4gIGdldE1hdHJpeCxcbiAgd29ybGRTY2FsZSxcbiAgbWVzaFR5cGU6IF9tZXNoVHlwZSA9IFwibWVzaFwiXG59KSA9PiB7XG4gIG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gIGNvbnN0IGludmVydGVkV29ybGRNYXRyaXggPSBvYmplY3QucGFyZW50Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG4gIHJldHVybiB7XG4gICAgb2JqZWN0LFxuICAgIHJpZ2lkQm9keSxcbiAgICBpbnZlcnRlZFdvcmxkTWF0cml4LFxuICAgIHNldE1hdHJpeDogc2V0TWF0cml4ID8gc2V0TWF0cml4IDogbWF0cml4ID0+IHtcbiAgICAgIG9iamVjdC5tYXRyaXguY29weShtYXRyaXgpO1xuICAgIH0sXG4gICAgZ2V0TWF0cml4OiBnZXRNYXRyaXggPyBnZXRNYXRyaXggOiBtYXRyaXggPT4gbWF0cml4LmNvcHkob2JqZWN0Lm1hdHJpeCksXG4gICAgc2NhbGU6IHdvcmxkU2NhbGUgfHwgb2JqZWN0LmdldFdvcmxkU2NhbGUoX3NjYWxlKS5jbG9uZSgpLFxuICAgIGlzU2xlZXBpbmc6IGZhbHNlLFxuICAgIG1lc2hUeXBlOiBfbWVzaFR5cGVcbiAgfTtcbn07XG5jb25zdCBpbW11dGFibGVSaWdpZEJvZHlPcHRpb25zID0gW1wiYXJnc1wiLCBcImNvbGxpZGVyc1wiLCBcImNhblNsZWVwXCJdO1xuY29uc3QgbXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMgPSB7XG4gIGdyYXZpdHlTY2FsZTogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLnNldEdyYXZpdHlTY2FsZSh2YWx1ZSwgdHJ1ZSk7XG4gIH0sXG4gIGxpbmVhckRhbXBpbmc6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRMaW5lYXJEYW1waW5nKHZhbHVlKTtcbiAgfSxcbiAgYW5ndWxhckRhbXBpbmc6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRBbmd1bGFyRGFtcGluZyh2YWx1ZSk7XG4gIH0sXG4gIGRvbWluYW5jZUdyb3VwOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0RG9taW5hbmNlR3JvdXAodmFsdWUpO1xuICB9LFxuICBlbmFibGVkUm90YXRpb25zOiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldEVuYWJsZWRSb3RhdGlvbnMoeCwgeSwgeiwgdHJ1ZSk7XG4gIH0sXG4gIGVuYWJsZWRUcmFuc2xhdGlvbnM6IChyYiwgW3gsIHksIHpdKSA9PiB7XG4gICAgcmIuc2V0RW5hYmxlZFRyYW5zbGF0aW9ucyh4LCB5LCB6LCB0cnVlKTtcbiAgfSxcbiAgbG9ja1JvdGF0aW9uczogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmxvY2tSb3RhdGlvbnModmFsdWUsIHRydWUpO1xuICB9LFxuICBsb2NrVHJhbnNsYXRpb25zOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIubG9ja1RyYW5zbGF0aW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gIH0sXG4gIGFuZ3VsYXJWZWxvY2l0eTogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRBbmd2ZWwoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIGxpbmVhclZlbG9jaXR5OiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldExpbnZlbCh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHpcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgY2NkOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuZW5hYmxlQ2NkKHZhbHVlKTtcbiAgfSxcbiAgdXNlckRhdGE6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi51c2VyRGF0YSA9IHZhbHVlO1xuICB9LFxuXG4gIHR5cGUocmIsIHZhbHVlKSB7XG4gICAgcmIuc2V0Qm9keVR5cGUocmlnaWRCb2R5VHlwZUZyb21TdHJpbmcodmFsdWUpLCB0cnVlKTtcbiAgfSxcblxuICBwb3NpdGlvbjogKCkgPT4ge30sXG4gIHJvdGF0aW9uOiAoKSA9PiB7fSxcbiAgcXVhdGVybmlvbjogKCkgPT4ge30sXG4gIHNjYWxlOiAoKSA9PiB7fVxufTtcbmNvbnN0IG11dGFibGVSaWdpZEJvZHlPcHRpb25LZXlzID0gT2JqZWN0LmtleXMobXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMpO1xuY29uc3Qgc2V0UmlnaWRCb2R5T3B0aW9ucyA9IChyaWdpZEJvZHksIG9wdGlvbnMsIHN0YXRlcywgdXBkYXRlVHJhbnNsYXRpb25zID0gdHJ1ZSkgPT4ge1xuICBpZiAoIXJpZ2lkQm9keSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChyaWdpZEJvZHkuaGFuZGxlKTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodXBkYXRlVHJhbnNsYXRpb25zKSB7XG4gICAgICBzdGF0ZS5vYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG4gICAgICBfbWF0cml4NC5jb3B5KHN0YXRlLm9iamVjdC5tYXRyaXhXb3JsZCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuXG4gICAgICByaWdpZEJvZHkuc2V0VHJhbnNsYXRpb24oX3Bvc2l0aW9uLCBmYWxzZSk7XG4gICAgICByaWdpZEJvZHkuc2V0Um90YXRpb24oX3JvdGF0aW9uLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgbXV0YWJsZVJpZ2lkQm9keU9wdGlvbktleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG11dGFibGVSaWdpZEJvZHlPcHRpb25zW2tleV0ocmlnaWRCb2R5LCBvcHRpb25zW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuY29uc3QgdXNlVXBkYXRlUmlnaWRCb2R5T3B0aW9ucyA9IChnZXRSaWdpZEJvZHksIHByb3BzLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyA9IHRydWUpID0+IHtcbiAgLy8gVE9ETzogSW1wcm92ZSB0aGlzLCBzcGxpdCBlYWNoIHByb3AgaW50byBpdHMgb3duIGVmZmVjdFxuICBjb25zdCBtdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSA9IHVzZU1lbW8oKCkgPT4gbXV0YWJsZVJpZ2lkQm9keU9wdGlvbktleXMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiB2ZWN0b3JUb1R1cGxlKHByb3BzW2tleV0pO1xuICB9KSwgW3Byb3BzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gZ2V0UmlnaWRCb2R5KCk7XG4gICAgc2V0UmlnaWRCb2R5T3B0aW9ucyhyaWdpZEJvZHksIHByb3BzLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyk7XG4gIH0sIG11dGFibGVQcm9wc0FzRmxhdEFycmF5KTtcbn07XG5jb25zdCB1c2VSaWdpZEJvZHlFdmVudHMgPSAoZ2V0UmlnaWRCb2R5LCBwcm9wcywgZXZlbnRzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvbldha2UsXG4gICAgb25TbGVlcCxcbiAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICBvbkludGVyc2VjdGlvbkVudGVyLFxuICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICBvbkNvbnRhY3RGb3JjZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSB7XG4gICAgb25XYWtlLFxuICAgIG9uU2xlZXAsXG4gICAgb25Db2xsaXNpb25FbnRlcixcbiAgICBvbkNvbGxpc2lvbkV4aXQsXG4gICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICBvbkludGVyc2VjdGlvbkV4aXQsXG4gICAgb25Db250YWN0Rm9yY2VcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByaWdpZEJvZHkgPSBnZXRSaWdpZEJvZHkoKTtcbiAgICBldmVudHMuc2V0KHJpZ2lkQm9keS5oYW5kbGUsIGV2ZW50SGFuZGxlcnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMuZGVsZXRlKHJpZ2lkQm9keS5oYW5kbGUpO1xuICAgIH07XG4gIH0sIFtvbldha2UsIG9uU2xlZXAsIG9uQ29sbGlzaW9uRW50ZXIsIG9uQ29sbGlzaW9uRXhpdCwgb25JbnRlcnNlY3Rpb25FbnRlciwgb25JbnRlcnNlY3Rpb25FeGl0LCBvbkNvbnRhY3RGb3JjZV0pO1xufTtcblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJjaGlsZHJlblwiLCBcInR5cGVcIiwgXCJwb3NpdGlvblwiLCBcInJvdGF0aW9uXCIsIFwic2NhbGVcIiwgXCJxdWF0ZXJuaW9uXCIsIFwidHJhbnNmb3JtU3RhdGVcIl07XG5jb25zdCBSaWdpZEJvZHlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IHVzZVJpZ2lkQm9keUNvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KFJpZ2lkQm9keUNvbnRleHQpO1xuXG4vKipcbiAqIEEgcmlnaWQgYm9keSBpcyBhIHBoeXNpY2FsIG9iamVjdCB0aGF0IGNhbiBiZSBzaW11bGF0ZWQgYnkgdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQGNhdGVnb3J5IENvbXBvbmVudHNcbiAqL1xuY29uc3QgUmlnaWRCb2R5ID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICB0eXBlLFxuICAgIHBvc2l0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIHF1YXRlcm5pb24sXG4gICAgdHJhbnNmb3JtU3RhdGVcbiAgfSA9IHByb3BzLFxuICAgICAgICBvYmplY3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuXG4gIGNvbnN0IG9iamVjdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmlnaWRCb2R5UmVmID0gdXNlRm9yd2FyZGVkUmVmKGZvcndhcmRlZFJlZik7XG4gIGNvbnN0IHtcbiAgICB3b3JsZCxcbiAgICByaWdpZEJvZHlTdGF0ZXMsXG4gICAgcGh5c2ljc09wdGlvbnMsXG4gICAgcmlnaWRCb2R5RXZlbnRzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGh5c2ljc09wdGlvbnMpLCBwcm9wcyksIHt9LCB7XG4gICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sIFtwaHlzaWNzT3B0aW9ucywgcHJvcHNdKTtcbiAgY29uc3QgaW1tdXRhYmxlUHJvcEFycmF5ID0gaW1tdXRhYmxlUmlnaWRCb2R5T3B0aW9ucy5mbGF0TWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWVyZ2VkT3B0aW9uc1trZXldKSA/IFsuLi5tZXJnZWRPcHRpb25zW2tleV1dIDogbWVyZ2VkT3B0aW9uc1trZXldO1xuICB9KTtcbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdFJlZiwgbWVyZ2VkT3B0aW9ucyk7IC8vIFByb3ZpZGUgYSB3YXkgdG8gZWFnZXJseSBjcmVhdGUgcmlnaWRib2R5XG5cbiAgY29uc3QgZ2V0UmlnaWRCb2R5ID0gdXNlSW1wZXJhdGl2ZUluc3RhbmNlKCgpID0+IHtcbiAgICBjb25zdCBkZXNjID0gcmlnaWRCb2R5RGVzY0Zyb21PcHRpb25zKG1lcmdlZE9wdGlvbnMpO1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IHdvcmxkLmNyZWF0ZVJpZ2lkQm9keShkZXNjKTtcblxuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvcndhcmRlZFJlZihyaWdpZEJvZHkpO1xuICAgIH1cblxuICAgIHJpZ2lkQm9keVJlZi5jdXJyZW50ID0gcmlnaWRCb2R5O1xuICAgIHJldHVybiByaWdpZEJvZHk7XG4gIH0sIHJpZ2lkQm9keSA9PiB7XG4gICAgaWYgKHdvcmxkLmdldFJpZ2lkQm9keShyaWdpZEJvZHkuaGFuZGxlKSkge1xuICAgICAgd29ybGQucmVtb3ZlUmlnaWRCb2R5KHJpZ2lkQm9keSk7XG4gICAgfVxuICB9LCBpbW11dGFibGVQcm9wQXJyYXkpOyAvLyBPbmx5IHByb3ZpZGUgYSBvYmplY3Qgc3RhdGUgYWZ0ZXIgdGhlIHJlZiBoYXMgYmVlbiBzZXRcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IGdldFJpZ2lkQm9keSgpO1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlUmlnaWRCb2R5U3RhdGUoe1xuICAgICAgcmlnaWRCb2R5LFxuICAgICAgb2JqZWN0OiBvYmplY3RSZWYuY3VycmVudFxuICAgIH0pO1xuICAgIHJpZ2lkQm9keVN0YXRlcy5zZXQocmlnaWRCb2R5LmhhbmRsZSwgcHJvcHMudHJhbnNmb3JtU3RhdGUgPyBwcm9wcy50cmFuc2Zvcm1TdGF0ZShzdGF0ZSkgOiBzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJpZ2lkQm9keVN0YXRlcy5kZWxldGUocmlnaWRCb2R5LmhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW2dldFJpZ2lkQm9keV0pO1xuICB1c2VVcGRhdGVSaWdpZEJvZHlPcHRpb25zKGdldFJpZ2lkQm9keSwgbWVyZ2VkT3B0aW9ucywgcmlnaWRCb2R5U3RhdGVzKTtcbiAgdXNlUmlnaWRCb2R5RXZlbnRzKGdldFJpZ2lkQm9keSwgbWVyZ2VkT3B0aW9ucywgcmlnaWRCb2R5RXZlbnRzKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZjogb2JqZWN0UmVmLFxuICAgICAgZ2V0UmlnaWRCb2R5OiBnZXRSaWdpZEJvZHksXG4gICAgICBvcHRpb25zOiBtZXJnZWRPcHRpb25zXG4gICAgfTtcbiAgfSwgW2dldFJpZ2lkQm9keV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmlnaWRCb2R5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBvYmplY3RSZWZcbiAgfSwgb2JqZWN0UHJvcHMsIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sXG4gICAgc2NhbGU6IHNjYWxlXG4gIH0pLCBjaGlsZHJlbiwgY2hpbGRDb2xsaWRlclByb3BzLm1hcCgoY29sbGlkZXJQcm9wcywgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBpbmRleFxuICB9LCBjb2xsaWRlclByb3BzKSkpKSk7XG59KSk7XG5SaWdpZEJvZHkuZGlzcGxheU5hbWUgPSBcIlJpZ2lkQm9keVwiO1xuXG4vKipcbiAqIEEgbWVzaCBjb2xsaWRlciBpcyBhIGNvbGxpZGVyIHRoYXQgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSB0aGUgZ2VvbWV0cnkgb2YgdGhlIGNoaWxkcmVuLlxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBNZXNoQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovbWVtbyhwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICB0eXBlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIHBoeXNpY3NPcHRpb25zXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3Qgb2JqZWN0ID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgb3B0aW9uc1xuICB9ID0gdXNlUmlnaWRCb2R5Q29udGV4dCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwaHlzaWNzT3B0aW9ucyksIG9wdGlvbnMpLCB7fSwge1xuICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgICAgIGNvbGxpZGVyczogdHlwZVxuICAgIH0pO1xuICB9LCBbcGh5c2ljc09wdGlvbnMsIG9wdGlvbnNdKTtcbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdCwgbWVyZ2VkT3B0aW9ucywgZmFsc2UpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCB7XG4gICAgcmVmOiBvYmplY3QsXG4gICAgdXNlckRhdGE6IHtcbiAgICAgIHIzUmFwaWVyVHlwZTogXCJNZXNoQ29sbGlkZXJcIlxuICAgIH1cbiAgfSwgY2hpbGRyZW4sIGNoaWxkQ29sbGlkZXJQcm9wcy5tYXAoKGNvbGxpZGVyUHJvcHMsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe1xuICAgIGtleTogaW5kZXhcbiAgfSwgY29sbGlkZXJQcm9wcykpKSk7XG59KTtcbk1lc2hDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiTWVzaENvbGxpZGVyXCI7XG5cbmNvbnN0IF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCIsIFwiaW5zdGFuY2VzXCIsIFwiY29sbGlkZXJOb2Rlc1wiLCBcInBvc2l0aW9uXCIsIFwicm90YXRpb25cIiwgXCJxdWF0ZXJuaW9uXCIsIFwic2NhbGVcIl07XG5jb25zdCBJbnN0YW5jZWRSaWdpZEJvZGllcyA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCByaWdpZEJvZGllc1JlZiA9IHVzZUZvcndhcmRlZFJlZihmb3J3YXJkZWRSZWYsIFtdKTtcbiAgY29uc3Qgb2JqZWN0UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBpbnN0YW5jZVdyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgY29uc3Qge1xuICAgIC8vIGluc3RhbmNlZCBwcm9wc1xuICAgIGNoaWxkcmVuLFxuICAgIGluc3RhbmNlcyxcbiAgICBjb2xsaWRlck5vZGVzID0gW10sXG4gICAgLy8gd3JhcHBlciBvYmplY3QgcHJvcHNcbiAgICBwb3NpdGlvbixcbiAgICByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlXG4gIH0gPSBwcm9wcyxcbiAgICAgICAgcmlnaWRCb2R5UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdFJlZiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByb3BzKSwge30sIHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0pKTtcblxuICBjb25zdCBnZXRJbnN0YW5jZWRNZXNoID0gKCkgPT4ge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBpbnN0YW5jZVdyYXBwZXJSZWYuY3VycmVudC5jaGlsZHJlblswXTtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIFwiaXNJbnN0YW5jZWRNZXNoXCIgaW4gZmlyc3RDaGlsZCkge1xuICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBnZXRJbnN0YW5jZWRNZXNoKCk7XG5cbiAgICBpZiAoaW5zdGFuY2VkTWVzaCkge1xuICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5zZXRVc2FnZShEeW5hbWljRHJhd1VzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2VkUmlnaWRCb2RpZXMgZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCwgd2hpY2ggbXVzdCBiZSBhbiBJbnN0YW5jZWRNZXNoXCIpO1xuICAgIH1cbiAgfSwgW10pOyAvLyBVcGRhdGUgdGhlIFJpZ2lkQm9keVN0YXRlcyB3aGVuZXZlciB0aGUgaW5zdGFuY2VzIGNoYW5nZVxuXG4gIGNvbnN0IGFwcGx5SW5zdGFuY2VkU3RhdGUgPSAoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IGdldEluc3RhbmNlZE1lc2goKTtcblxuICAgIGlmIChpbnN0YW5jZWRNZXNoKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgZ2V0TWF0cml4OiBtYXRyaXggPT4ge1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCk7XG4gICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF0cml4OiBtYXRyaXggPT4ge1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCk7XG4gICAgICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG1lc2hUeXBlOiBcImluc3RhbmNlZE1lc2hcIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IG9iamVjdFJlZlxuICB9LCByaWdpZEJvZHlQcm9wcywge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHJlZjogaW5zdGFuY2VXcmFwcGVyUmVmXG4gIH0sIGNoaWxkcmVuKSwgaW5zdGFuY2VzID09PSBudWxsIHx8IGluc3RhbmNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSaWdpZEJvZHksIF9leHRlbmRzKHt9LCByaWdpZEJvZHlQcm9wcywgaW5zdGFuY2UsIHtcbiAgICByZWY6IGJvZHkgPT4gcmlnaWRCb2RpZXNSZWYuY3VycmVudFtpbmRleF0gPSBib2R5LFxuICAgIHRyYW5zZm9ybVN0YXRlOiBzdGF0ZSA9PiBhcHBseUluc3RhbmNlZFN0YXRlKHN0YXRlLCBpbmRleClcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb2xsaWRlck5vZGVzLm1hcCgobm9kZSwgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7XG4gICAga2V5OiBpbmRleFxuICB9LCBub2RlKSksIGNoaWxkQ29sbGlkZXJQcm9wcy5tYXAoKGNvbGxpZGVyUHJvcHMsIGNvbGxpZGVySW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBjb2xsaWRlckluZGV4XG4gIH0sIGNvbGxpZGVyUHJvcHMpKSkpKSkpO1xufSkpO1xuSW5zdGFuY2VkUmlnaWRCb2RpZXMuZGlzcGxheU5hbWUgPSBcIkluc3RhbmNlZFJpZ2lkQm9kaWVzXCI7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuY29uc3QgdXNlSW1wdWxzZUpvaW50ID0gKGJvZHkxLCBib2R5MiwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB3b3JsZFxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IGpvaW50UmVmID0gdXNlUmVmKCk7XG4gIHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgaWYgKGJvZHkxLmN1cnJlbnQgJiYgYm9keTIuY3VycmVudCkge1xuICAgICAgY29uc3QgbmV3Sm9pbnQgPSB3b3JsZC5jcmVhdGVJbXB1bHNlSm9pbnQocGFyYW1zLCBib2R5MS5jdXJyZW50LCBib2R5Mi5jdXJyZW50LCB0cnVlKTtcbiAgICAgIGpvaW50UmVmLmN1cnJlbnQgPSBuZXdKb2ludDtcbiAgICAgIHJldHVybiBuZXdKb2ludDtcbiAgICB9XG4gIH0sIGpvaW50ID0+IHtcbiAgICBpZiAoam9pbnQpIHtcbiAgICAgIGpvaW50UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh3b3JsZC5nZXRJbXB1bHNlSm9pbnQoam9pbnQuaGFuZGxlKSkge1xuICAgICAgICB3b3JsZC5yZW1vdmVJbXB1bHNlSm9pbnQoam9pbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gam9pbnRSZWY7XG59O1xuLyoqXG4gKiBBIGZpeGVkIGpvaW50IGVuc3VyZXMgdGhhdCB0d28gcmlnaWQtYm9kaWVzIGRvbid0IG1vdmUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci5cbiAqIEZpeGVkIGpvaW50cyBhcmUgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgZnJhbWUgKHJlcHJlc2VudGVkIGJ5IGFuIGlzb21ldHJ5KSBvbiBlYWNoIHJpZ2lkLWJvZHkuXG4gKiBUaGUgZml4ZWQtam9pbnQgbWFrZXMgdGhlc2UgZnJhbWVzIGNvaW5jaWRlIGluIHdvcmxkLXNwYWNlLlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZUZpeGVkSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkxTG9jYWxGcmFtZSwgYm9keTJBbmNob3IsIGJvZHkyTG9jYWxGcmFtZV0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCByYXBpZXIuSm9pbnREYXRhLmZpeGVkKHZlY3RvckFycmF5VG9WZWN0b3IzKGJvZHkxQW5jaG9yKSwgdHVwbGVUb09iamVjdChib2R5MUxvY2FsRnJhbWUsIFtcInhcIiwgXCJ5XCIsIFwielwiLCBcIndcIl0pLCB2ZWN0b3JBcnJheVRvVmVjdG9yMyhib2R5MkFuY2hvciksIHR1cGxlVG9PYmplY3QoYm9keTJMb2NhbEZyYW1lLCBbXCJ4XCIsIFwieVwiLCBcInpcIiwgXCJ3XCJdKSkpO1xufTtcbi8qKlxuICogVGhlIHNwaGVyaWNhbCBqb2ludCBlbnN1cmVzIHRoYXQgdHdvIHBvaW50cyBvbiB0aGUgbG9jYWwtc3BhY2VzIG9mIHR3byByaWdpZC1ib2RpZXMgYWx3YXlzIGNvaW5jaWRlIChpdCBwcmV2ZW50cyBhbnkgcmVsYXRpdmVcbiAqIHRyYW5zbGF0aW9uYWwgbW90aW9uIGF0IHRoaXMgcG9pbnRzKS4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBzaW11bGF0ZSByYWdkb2xscyBhcm1zLCBwZW5kdWx1bXMsIGV0Yy5cbiAqIFRoZXkgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGFuY2hvciBvbiBlYWNoIHJpZ2lkLWJvZHkuIEVhY2ggYW5jaG9yIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZVxuICogcG9pbnRzIHRoYXQgbmVlZCB0byBjb2luY2lkZSBvbiB0aGUgbG9jYWwtc3BhY2Ugb2YgZWFjaCByaWdpZC1ib2R5LlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZVNwaGVyaWNhbEpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvcl0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCByYXBpZXIuSm9pbnREYXRhLnNwaGVyaWNhbCh2ZWN0b3JBcnJheVRvVmVjdG9yMyhib2R5MUFuY2hvciksIHZlY3RvckFycmF5VG9WZWN0b3IzKGJvZHkyQW5jaG9yKSkpO1xufTtcbi8qKlxuICogVGhlIHJldm9sdXRlIGpvaW50IHByZXZlbnRzIGFueSByZWxhdGl2ZSBtb3ZlbWVudCBiZXR3ZWVuIHR3byByaWdpZC1ib2RpZXMsIGV4Y2VwdCBmb3IgcmVsYXRpdmVcbiAqIHJvdGF0aW9ucyBhbG9uZyBvbmUgYXhpcy4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBzaW11bGF0ZSB3aGVlbHMsIGZhbnMsIGV0Yy5cbiAqIFRoZXkgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGFuY2hvciBhcyB3ZWxsIGFzIG9uZSBsb2NhbCBheGlzIG9uIGVhY2ggcmlnaWQtYm9keS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuXG5jb25zdCB1c2VSZXZvbHV0ZUpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgYXhpcywgbGltaXRzXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5yZXZvbHV0ZSh2ZWN0b3JBcnJheVRvVmVjdG9yMyhib2R5MUFuY2hvciksIHZlY3RvckFycmF5VG9WZWN0b3IzKGJvZHkyQW5jaG9yKSwgdmVjdG9yQXJyYXlUb1ZlY3RvcjMoYXhpcykpO1xuXG4gIGlmIChsaW1pdHMpIHtcbiAgICBwYXJhbXMubGltaXRzRW5hYmxlZCA9IHRydWU7XG4gICAgcGFyYW1zLmxpbWl0cyA9IGxpbWl0cztcbiAgfVxuXG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcbi8qKlxuICogVGhlIHByaXNtYXRpYyBqb2ludCBwcmV2ZW50cyBhbnkgcmVsYXRpdmUgbW92ZW1lbnQgYmV0d2VlbiB0d28gcmlnaWQtYm9kaWVzLCBleGNlcHQgZm9yIHJlbGF0aXZlIHRyYW5zbGF0aW9ucyBhbG9uZyBvbmUgYXhpcy5cbiAqIEl0IGlzIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGFuY2hvciBhcyB3ZWxsIGFzIG9uZSBsb2NhbCBheGlzIG9uIGVhY2ggcmlnaWQtYm9keS4gSW4gM0QsIGFuIG9wdGlvbmFsXG4gKiBsb2NhbCB0YW5nZW50IGF4aXMgY2FuIGJlIHNwZWNpZmllZCBmb3IgZWFjaCByaWdpZC1ib2R5LlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZVByaXNtYXRpY0pvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgYXhpcywgbGltaXRzXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5wcmlzbWF0aWModmVjdG9yQXJyYXlUb1ZlY3RvcjMoYm9keTFBbmNob3IpLCB2ZWN0b3JBcnJheVRvVmVjdG9yMyhib2R5MkFuY2hvciksIHZlY3RvckFycmF5VG9WZWN0b3IzKGF4aXMpKTtcblxuICBpZiAobGltaXRzKSB7XG4gICAgcGFyYW1zLmxpbWl0c0VuYWJsZWQgPSB0cnVlO1xuICAgIHBhcmFtcy5saW1pdHMgPSBsaW1pdHM7XG4gIH1cblxuICByZXR1cm4gdXNlSW1wdWxzZUpvaW50KGJvZHkxLCBib2R5MiwgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhbiBJbnRlcmFjdGlvbkdyb3VwIGJpdG1hc2sgZm9yIHVzZSBpbiB0aGUgYGNvbGxpc2lvbkdyb3Vwc2Agb3IgYHNvbHZlckdyb3Vwc2BcbiAqIHByb3BlcnRpZXMgb2YgUmlnaWRCb2R5IG9yIENvbGxpZGVyIGNvbXBvbmVudHMuIFRoZSBmaXJzdCBhcmd1bWVudCByZXByZXNlbnRzIGEgbGlzdCBvZlxuICogZ3JvdXBzIHRoZSBlbnRpdHkgaXMgaW4gKGV4cHJlc3NlZCBhcyBudW1iZXJzIGZyb20gMCB0byAxNSkuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBsaXN0XG4gKiBvZiBncm91cHMgdGhhdCB3aWxsIGJlIGZpbHRlcmVkIGFnYWluc3QuIFdoZW4gaXQgaXMgb21pdHRlZCwgYWxsIGdyb3VwcyBhcmUgZmlsdGVyZWQgYWdhaW5zdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogQSBSaWdpZEJvZHkgdGhhdCBpcyBtZW1iZXIgb2YgZ3JvdXAgMCBhbmQgd2lsbCBjb2xsaWRlIHdpdGggZXZlcnl0aGluZyBmcm9tIGdyb3VwcyAwIGFuZCAxOlxuICpcbiAqIGBgYHRzeFxuICogPFJpZ2lkQm9keSBjb2xsaXNpb25Hcm91cHM9e2ludGVyYWN0aW9uR3JvdXBzKFswXSwgWzAsIDFdKX0gLz5cbiAqIGBgYFxuICpcbiAqIEEgUmlnaWRCb2R5IHRoYXQgaXMgbWVtYmVyIG9mIGdyb3VwcyAwIGFuZCAxIGFuZCB3aWxsIGNvbGxpZGUgd2l0aCBldmVyeXRoaW5nIGVsc2U6XG4gKlxuICogYGBgdHN4XG4gKiA8UmlnaWRCb2R5IGNvbGxpc2lvbkdyb3Vwcz17aW50ZXJhY3Rpb25Hcm91cHMoWzAsIDFdKX0gLz5cbiAqIGBgYFxuICpcbiAqIEEgUmlnaWRCb2R5IHRoYXQgaXMgbWVtYmVyIG9mIGdyb3VwcyAwIGFuZCAxIGFuZCB3aWxsIG5vdCBjb2xsaWRlIHdpdGggYW55dGhpbmc6XG4gKlxuICogYGBgdHN4XG4gKiA8UmlnaWRCb2R5IGNvbGxpc2lvbkdyb3Vwcz17aW50ZXJhY3Rpb25Hcm91cHMoWzAsIDFdLCBbXSl9IC8+XG4gKiBgYGBcbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IFJhcGllciBuZWVkcyBpbnRlcmFjdGlvbiBmaWx0ZXJzIHRvIGV2YWx1YXRlIHRvIHRydWUgYmV0d2VlbiBfYm90aF8gY29sbGlkaW5nXG4gKiBlbnRpdGllcyBmb3IgY29sbGlzaW9uIGV2ZW50cyB0byB0cmlnZ2VyLlxuICpcbiAqIEBwYXJhbSBtZW1iZXJzaGlwcyBHcm91cHMgdGhlIGNvbGxpZGVyIGlzIGEgbWVtYmVyIG9mLiAoVmFsdWVzIGNhbiByYW5nZSBmcm9tIDAgdG8gMTUuKVxuICogQHBhcmFtIGZpbHRlcnMgR3JvdXBzIHRoZSBpbnRlcmFjdGlvbiBncm91cCBzaG91bGQgZmlsdGVyIGFnYWluc3QuIChWYWx1ZXMgY2FuIHJhbmdlIGZyb20gMCB0byAxNS4pXG4gKiBAcmV0dXJucyBBbiBJbnRlcmFjdGlvbkdyb3VwIGJpdG1hc2suXG4gKi9cbmNvbnN0IGludGVyYWN0aW9uR3JvdXBzID0gKG1lbWJlcnNoaXBzLCBmaWx0ZXJzKSA9PiAoYml0bWFzayhtZW1iZXJzaGlwcykgPDwgMTYpICsgKGZpbHRlcnMgIT09IHVuZGVmaW5lZCA/IGJpdG1hc2soZmlsdGVycykgOiAwYjExMTExMTExMTExMTExMTEpO1xuXG5jb25zdCBiaXRtYXNrID0gZ3JvdXBzID0+IFtncm91cHNdLmZsYXQoKS5yZWR1Y2UoKGFjYywgbGF5ZXIpID0+IGFjYyB8IDEgPDwgbGF5ZXIsIDApO1xuXG5leHBvcnQgeyBBbnlDb2xsaWRlciwgQmFsbENvbGxpZGVyLCBDYXBzdWxlQ29sbGlkZXIsIENvbmVDb2xsaWRlciwgQ29udmV4SHVsbENvbGxpZGVyLCBDdWJvaWRDb2xsaWRlciwgQ3lsaW5kZXJDb2xsaWRlciwgSGVpZ2h0ZmllbGRDb2xsaWRlciwgSW5zdGFuY2VkUmlnaWRCb2RpZXMsIE1lc2hDb2xsaWRlciwgUGh5c2ljcywgUmlnaWRCb2R5LCBSb3VuZENvbmVDb2xsaWRlciwgUm91bmRDdWJvaWRDb2xsaWRlciwgUm91bmRDeWxpbmRlckNvbGxpZGVyLCBUcmltZXNoQ29sbGlkZXIsIGV1bGVyLCBpbnRlcmFjdGlvbkdyb3VwcywgcXVhdCwgdXNlQWZ0ZXJQaHlzaWNzU3RlcCwgdXNlQmVmb3JlUGh5c2ljc1N0ZXAsIHVzZUZpeGVkSm9pbnQsIHVzZUltcHVsc2VKb2ludCwgdXNlUHJpc21hdGljSm9pbnQsIHVzZVJhcGllciwgdXNlUmV2b2x1dGVKb2ludCwgdXNlU3BoZXJpY2FsSm9pbnQsIHZlYzMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-three+rapier@1.1.2_@react-three+fiber@8.13.4_react@19.0.0_three@0.158.0/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js\n");

/***/ })

};
;